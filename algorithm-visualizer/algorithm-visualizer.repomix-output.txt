This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document.
Generated by Repomix on: 2025-03-18T12:07:58.661Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.js
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
Backtracking/
  Knight's Tour Problem/
    code.js
  N-Queens Problem/
    code.js
Branch and Bound/
  Binary Search/
    iterative.js
    recursive.js
  Binary Search Tree/
    insertion.js
    search.js
  Depth-Limited Search/
    code.js
  Topological Sort/
    code.js
Brute Force/
  Binary Tree Traversal/
    inOrder.js
    postOrder.js
    preOrder.js
  Bipartiteness Test/
    code.js
  Breadth-First Search/
    shortestPath.js
    tree.js
  Bridge Finding/
    efficient.js
    naive.js
  Bubble Sort/
    code.js
  Comb Sort/
    code.js
  Cycle Sort/
    code.js
  Depth-First Search/
    graph.js
    shortestPath.js
    tree.js
    weightedGraph.js
  Flood Fill/
    code.js
  Heapsort/
    code.js
  Insertion Sort/
    code.js
  Lowest Common Ancestor/
    code.js
  PageRank/
    code.js
  Pancake Sort/
    code.js
  Rabin-Karp's String Search/
    code.js
  Selection Sort/
    code.js
  Shellsort/
    code.js
  Tarjan's Strongly Connected Components/
    code.js
Divide and Conquer/
  Bucket Sort/
    code.js
  Counting Sort/
    code.js
  Merge Sort/
    bottomUp.js
    topDown.js
  Pigeonhole Sort/
    code.js
  Quicksort/
    code.js
  Radix Sort/
    leastSignificantDigit.js
Dynamic Programming/
  Bellman-Ford's Shortest Path/
    code.js
  Catalan Number/
    code.js
  Fibonacci Sequence/
    code.js
  Floyd-Warshall's Shortest Path/
    code.js
  Integer Partition/
    code.js
  Knapsack Problem/
    code.js
  Knuth-Morris-Pratt's String Search/
    code.js
  Levenshtein's Edit Distance/
    code.js
  Longest Common Subsequence/
    code.js
  Longest Increasing Subsequence/
    code.js
  Longest Palindromic Subsequence/
    code.js
  Maximum Subarray/
    code.js
  Maximum Sum Path/
    code.js
  Nth Factorial/
    code.js
  Pascal's Triangle/
    code.js
  Shortest Common Supersequence/
    code.js
  Sieve of Eratosthenes/
    code.js
  Sliding Window/
    code.js
  Ugly Numbers/
    code.js
  Z String Search/
    code.js
Greedy/
  Boyerâ€“Moore's Majority Vote/
    code.js
  Dijkstra's Shortest Path/
    code.js
  Job Scheduling Problem/
    code.js
  Kruskal's Minimum Spanning Tree/
    code.js
  Prim's Minimum Spanning Tree/
    code.js
  Stable Matching/
    code.js
Simple Recursive/
  Cellular Automata/
    code.js
  Cycle Detection/
    code.js
  Euclidean Greatest Common Divisor/
    code.js
  Nth Factorial/
    code.js
  Suffix Array/
    code.js

================================================================
Files
================================================================

================
File: Backtracking/Knight's Tour Problem/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Array2DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

/*
For N>3 the time taken by this algorithm is sufficiently high
Also it is not possible to visualise for N>6 due to stack overflow
caused by large number of recursive calls
*/
const N = 3;
const board = new Array(N);
for (let i = board.length - 1; i >= 0; i--) {
  board[i] = new Array(N);
}

for (let i = board.length - 1; i >= 0; i--) {
  for (let j = board[i].length - 1; j >= 0; j--) {
    board[i][j] = -1;
  }
}

/*
Define the next move of the knight
*/
const X = [2, 1, -1, -2, -2, -1, 1, 2];
const Y = [1, 2, 2, 1, -1, -2, -2, -1];

const pos = new Array(2);
pos[0] = pos[1] = -1;

// define tracer variables {
const boardTracer = new Array2DTracer('Board');
const posTracer = new Array1DTracer('Knight Position');
const logTracer = new LogTracer('Console');
boardTracer.set(board);
posTracer.set(pos);
Layout.setRoot(new VerticalLayout([boardTracer, posTracer, logTracer]));
Tracer.delay();
// }

function knightTour(x, y, moveNum) {
  if (moveNum === N * N) {
    return true;
  }

  for (let i = 0; i < 8; i++) {
    const nextX = x + X[i];
    const nextY = y + Y[i];

    // visualize {
    posTracer.patch(0, nextX);
    Tracer.delay();
    posTracer.patch(1, nextY);
    Tracer.delay();
    posTracer.depatch(0);
    posTracer.depatch(1);
    // }
    /*
    Check if knight is still in the board
    Check that knight does not visit an already visited square
    */
    if (nextX >= 0 && nextX < N && nextY >= 0 && nextY < N && board[nextX][nextY] === -1) {
      board[nextX][nextY] = moveNum;

      // visualize {
      logTracer.println(`Move to ${nextX},${nextY}`);
      boardTracer.patch(nextX, nextY, moveNum);
      Tracer.delay();
      boardTracer.depatch(nextX, nextY);
      boardTracer.select(nextX, nextY);
      // }

      const nextMoveNum = moveNum + 1;
      if (knightTour(nextX, nextY, nextMoveNum) === true) {
        return true;
      }

      // logger {
      logTracer.println(`No place to move from ${nextX},${nextY}: Backtrack`);
      // }
      board[nextX][nextY] = -1; // backtrack
      // visualize {
      boardTracer.patch(nextX, nextY, -1);
      Tracer.delay();
      boardTracer.depatch(nextX, nextY);
      boardTracer.deselect(nextX, nextY);
      // }
    } else {
      // logger {
      logTracer.println(`${nextX},${nextY} is not a valid move`);
      // }
    }
  }
  return false;
}

board[0][0] = 0; // start from this position
pos[0] = 0;
pos[0] = 0;

// visualize {
boardTracer.patch(0, 0, 0);
Tracer.delay();
posTracer.patch(0, 0);
Tracer.delay();
posTracer.patch(1, 0);
Tracer.delay();
boardTracer.depatch(0, 0);
boardTracer.depatch(0, 0);
posTracer.depatch(0);
posTracer.depatch(1);
// }

// logger {
if (knightTour(0, 0, 1) === false) {
  logTracer.println('Solution does not exist');
} else {
  logTracer.println('Solution found');
}
// }

================
File: Backtracking/N-Queens Problem/code.js
================
// import visualization libraries {
const { Tracer, Array2DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const N = 4; // just change the value of N and the visuals will reflect the configuration!
const board = (function createArray(N) {
  const result = [];
  for (let i = 0; i < N; i++) {
    result[i] = Array(...Array(N)).map(Number.prototype.valueOf, 0);
  }
  return result;
}(N));
const queens = (function qSetup(N) {
  const result = [];
  for (let i = 0; i < N; i++) {
    result[i] = [-1, -1];
  }
  return result;
}(N));

// define tracer variables {
const boardTracer = new Array2DTracer('Board');
const queenTracer = new Array2DTracer('Queen Positions');
const logger = new LogTracer('Progress');
Layout.setRoot(new VerticalLayout([boardTracer, queenTracer, logger]));

boardTracer.set(board);
queenTracer.set(queens);
logger.println(`N Queens: ${N}X${N}matrix, ${N} queens`);
Tracer.delay();
// }

function validState(row, col, currentQueen) {
  for (let q = 0; q < currentQueen; q++) {
    const currentQ = queens[q];
    if (row === currentQ[0] || col === currentQ[1] || (Math.abs(currentQ[0] - row) === Math.abs(currentQ[1] - col))) {
      return false;
    }
  }
  return true;
}

function nQ(currentQueen, currentCol) {
  // logger {
  logger.println(`Starting new iteration of nQueens () with currentQueen = ${currentQueen} & currentCol = ${currentCol}`);
  logger.println('------------------------------------------------------------------');
  // }
  if (currentQueen >= N) {
    // logger {
    logger.println('The recursion has BOTTOMED OUT. All queens have been placed successfully');
    // }
    return true;
  }

  let found = false;
  let row = 0;
  while ((row < N) && (!found)) {
    // visualize {
    boardTracer.select(row, currentCol);
    Tracer.delay();
    logger.println(`Trying queen ${currentQueen} at row ${row} & col ${currentCol}`);
    // }
    
    if (validState(row, currentCol, currentQueen)) {
      queens[currentQueen][0] = row;
      queens[currentQueen][1] = currentCol;

      // visualize {
      queenTracer.patch(currentQueen, 0, row);
      Tracer.delay();
      queenTracer.patch(currentQueen, 1, currentCol);
      Tracer.delay();
      queenTracer.depatch(currentQueen, 0);
      Tracer.delay();
      queenTracer.depatch(currentQueen, 1);
      Tracer.delay();
      // }
      
      found = nQ(currentQueen + 1, currentCol + 1);
    }

    if (!found) {
      // visualize {
      boardTracer.deselect(row, currentCol);
      Tracer.delay();
      logger.println(`row ${row} & col ${currentCol} didn't work out. Going down`);
      // }
    }
    row++;
  }

  return found;
}

// logger {
logger.println('Starting execution');
// }
nQ(0, 0);
// logger {
logger.println('DONE');
// }

================
File: Branch and Bound/Binary Search/iterative.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const chart = new ChartTracer();
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([chart, tracer, logger]));
const D = Randomize.Array1D({ N: 15, value: () => Randomize.Integer({ min: 0, max: 50 }), sorted: true });
tracer.set(D);
tracer.chart(chart);
Tracer.delay();
// }

function BinarySearch(array, element) { // array = sorted array, element = element to be found
  let minIndex = 0;
  let maxIndex = array.length - 1;
  let testElement;

  while (minIndex <= maxIndex) {
    const middleIndex = Math.floor((minIndex + maxIndex) / 2);
    testElement = array[middleIndex];

    // visualize {
    tracer.select(minIndex, maxIndex);
    Tracer.delay();
    tracer.patch(middleIndex);
    logger.println(`Searching at index: ${middleIndex}`);
    Tracer.delay();
    tracer.depatch(middleIndex);
    tracer.deselect(minIndex, maxIndex);
    // }

    if (testElement < element) {
      // logger {
      logger.println('Going right.');
      // }
      minIndex = middleIndex + 1;
    } else if (testElement > element) {
      // logger {
      logger.println('Going left.');
      // }
      maxIndex = middleIndex - 1;
    } else {
      // visualize {
      logger.println(`${element} is found at position ${middleIndex}!`);
      tracer.select(middleIndex);
      // }

      return middleIndex;
    }
  }

  // logger {
  logger.println(`${element} is not found!`);
  // }
  return -1;
}

const element = D[Randomize.Integer({ min: 0, max: D.length - 1 })];

// logger {
logger.println(`Using iterative binary search to find ${element}`);
// }
BinarySearch(D, element);

================
File: Branch and Bound/Binary Search/recursive.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const chart = new ChartTracer();
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([chart, tracer, logger]));
const D = Randomize.Array1D({ N: 15, value: () => Randomize.Integer({ min: 0, max: 50 }), sorted: true });
tracer.set(D);
tracer.chart(chart);
Tracer.delay();
// }

function BinarySearch(array, element, minIndex, maxIndex) { // array = sorted array, element = element to be found, minIndex = low index, maxIndex = high index
  if (minIndex > maxIndex) {
    // logger {
    logger.println(`${element} is not found!`);
    // }
    return -1;
  }

  const middleIndex = Math.floor((minIndex + maxIndex) / 2);
  const testElement = array[middleIndex];

  // visualize {
  tracer.select(minIndex, maxIndex);
  Tracer.delay();
  tracer.patch(middleIndex);
  logger.println(`Searching at index: ${middleIndex}`);
  Tracer.delay();
  tracer.depatch(middleIndex);
  tracer.deselect(minIndex, maxIndex);
  // }

  if (testElement < element) {
    // logger {
    logger.println('Going right.');
    // }
    return BinarySearch(array, element, middleIndex + 1, maxIndex);
  }

  if (testElement > element) {
    // logger {
    logger.println('Going left.');
    // }
    return BinarySearch(array, element, minIndex, middleIndex - 1);
  }

  if (testElement === element) {
    // visualize {
    logger.println(`${element} is found at position ${middleIndex}!`);
    tracer.select(middleIndex);
    // }
    return middleIndex;
  }

  // logger {
  logger.println(`${element} is not found!`);
  // }
  return -1;
}

const element = D[Randomize.Integer({ min: 0, max: D.length - 1 })];

// logger {
logger.println(`Using binary search to find ${element}`);
// }
BinarySearch(D, element, 0, D.length - 1);

================
File: Branch and Bound/Binary Search Tree/insertion.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const T = {};

const elements = [5, 8, 10, 3, 1, 6, 9, 7, 2, 0, 4]; // item to be inserted

// define tracer variables {
const graphTracer = new GraphTracer(' BST - Elements marked red indicates the current status of tree ');
const elemTracer = new Array1DTracer(' Elements ');
const logger = new LogTracer(' Log ');
Layout.setRoot(new VerticalLayout([graphTracer, elemTracer, logger]));
elemTracer.set(elements);
graphTracer.log(logger);
Tracer.delay();
// }

function bstInsert(root, element, parent) { // root = current node , parent = previous node
  // visualize {
  graphTracer.visit(root, parent);
  Tracer.delay();
  // }
  const treeNode = T[root];
  let propName = '';
  if (element < root) {
    propName = 'left';
  } else if (element > root) {
    propName = 'right';
  }
  if (propName !== '') {
    if (!(propName in treeNode)) { // insert as left child of root
      treeNode[propName] = element;
      T[element] = {};
      // visualize {
      graphTracer.addNode(element);
      graphTracer.addEdge(root, element);
      graphTracer.select(element, root);
      Tracer.delay();
      graphTracer.deselect(element, root);
      logger.println(`${element} Inserted`);
      // }
    } else {
      bstInsert(treeNode[propName], element, root);
    }
  }
  // visualize {
  graphTracer.leave(root, parent);
  Tracer.delay();
  // }
}

const Root = elements[0]; // take first element as root
T[Root] = {};
// visualize {
graphTracer.addNode(Root);
graphTracer.layoutTree(Root, true);
logger.println(`${Root} Inserted as root of tree `);
// }

for (let i = 1; i < elements.length; i++) {
  // visualize {
  elemTracer.select(i);
  Tracer.delay();
  // }
  bstInsert(Root, elements[i]); // insert ith element
  // visualize {
  elemTracer.deselect(i);
  Tracer.delay();
  // }
}

================
File: Branch and Bound/Binary Search Tree/search.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const G = [ // G[i][j] indicates whether the path from the i-th node to the j-th node exists or not
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
];

const T = [ // mapping to G as a binary tree , [i][0] indicates left child, [i][1] indicates right child
  [-1, -1],
  [0, 2],
  [-1, -1],
  [1, 4],
  [-1, -1],
  [3, 8],
  [-1, 7],
  [-1, -1],
  [6, 10],
  [-1, -1],
  [9, -1],
];

const key = Randomize.Integer({ min: 0, max: G.length - 1 }); // item to be searched
// define tracer variables {
const tracer = new GraphTracer(' Binary Search Tree ');
const logger = new LogTracer(' Log ');
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.set(G);
tracer.layoutTree(5);
tracer.log(logger);
Tracer.delay();
// }

function bst(item, node, parent) { // node = current node , parent = previous node
  // visualize {
  tracer.visit(node, parent);
  Tracer.delay();
  // }
  if (item === node) { // key found
    // logger {
    logger.println(' Match Found ');
    // }
  } else if (item < node) { // key less than value of current node
    if (T[node][0] === -1) {
      // logger {
      logger.println(' Not Found ');
      // }
    } else {
      bst(item, T[node][0], node);
    }
  } else { // key greater than value of current node
    if (T[node][1] === -1) {
      // logger {
      logger.println(' Not Found ');
      // }
    } else {
      bst(item, T[node][1], node);
    }
  }
}

// logger {
logger.println(`Finding number ${key}`);
// }
bst(key, 5); // node with key 5 is the root

================
File: Branch and Bound/Depth-Limited Search/code.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const G = [ // G[i][j] indicates whether the path from the i-th node to the j-th node exists or not
  [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
];

// define tracer variables {
const tracer = new GraphTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.log(logger);
tracer.set(G);
tracer.layoutTree(0);
Tracer.delay();
// }

// This is a sample DLS applications where
// we try to find number of descendant of root within some depth
function DLSCount(limit, node, parent) { // node = current node, parent = previous node
  // visualize {
  tracer.visit(node, parent);
  Tracer.delay();
  // }
  let child = 0;
  if (limit > 0) { // cut off the search
    for (let i = 0; i < G[node].length; i++) {
      if (G[node][i]) { // if current node has the i-th node as a child
        child += 1 + DLSCount(limit - 1, i, node); // recursively call DLS
      }
    }
    return child;
  }
  return child;
}

// logger {
logger.println(`Number of descendant is ${DLSCount(2, 0)}`);
// }

================
File: Branch and Bound/Topological Sort/code.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// G[i][j] indicates whether the path from the i-th node to the j-th node exists or not. NOTE: The graph must be Directed-Acyclic
const G = [
  [0, 0, 0, 0, 0, 0],
  [0, 0, 1, 0, 0, 0],
  [0, 0, 0, 1, 0, 0],
  [0, 0, 0, 0, 0, 0],
  [1, 0, 0, 1, 0, 0],
  [1, 1, 0, 0, 0, 0],
];

// define tracer variables {
const tracer = new GraphTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.log(logger);
tracer.set(G);
Tracer.delay();
// }

const inDegrees = Array(...Array(G.length)).map(Number.prototype.valueOf, 0); // create an Array of G.length number of 0s
const Q = [];
let iter = 0;
let i;

// logger {
logger.println('Calculating in-degrees for each Node...');
// }

for (let currNode = 0; currNode < G.length; currNode++) {
  for (let currNodeNeighbor = 0; currNodeNeighbor < G.length; currNodeNeighbor++) {
    if (G[currNode][currNodeNeighbor]) {
      // visualize {
      logger.println(`${currNodeNeighbor} has an incoming edge from ${currNode}`);
      tracer.visit(currNodeNeighbor, currNode);
      Tracer.delay();
      // }
      inDegrees[currNodeNeighbor]++;
      // visualize {
      tracer.leave(currNodeNeighbor, currNode);
      Tracer.delay();
      // }
    }
  }
}
// logger {
logger.println(`Done. In-Degrees are: [ ${String(inDegrees)} ]`);
logger.println('');

logger.println('Initializing queue with all the sources (nodes with no incoming edges)');
// }
inDegrees.map((indegrees, node) => {
  // visualize {
  tracer.visit(node);
  Tracer.delay();
  // }
  if (!indegrees) {
    // logger {
    logger.println(`${node} is a source`);
    // }
    Q.push(node);
  }
  // visualize {
  tracer.leave(node);
  Tracer.delay();
  // }
});
// logger {
logger.println(`Done. Initial State of Queue: [ ${String(Q)} ]`);
logger.println('');
// }

// begin topological sort (kahn)
while (Q.length > 0) {
  // logger {
  logger.println(`Iteration #${iter}. Queue state: [ ${String(Q)} ]`);
  // }
  const currNode = Q.shift();
  // visualize {
  tracer.visit(currNode);
  Tracer.delay();
  // }

  for (i = 0; i < G.length; i++) {
    if (G[currNode][i]) {
      // visualize {
      logger.println(`${i} has an incoming edge from ${currNode}. Decrementing ${i}'s in-degree by 1.`);
      tracer.visit(i, currNode);
      Tracer.delay();
      // }
      inDegrees[i]--;
      // visualize {
      tracer.leave(i, currNode);
      Tracer.delay();
      // }

      if (!inDegrees[i]) {
        // logger {
        logger.println(`${i}'s in-degree is now 0. Enqueuing ${i}`);
        // }
        Q.push(i);
      }
    }
  }
  // visualize {
  tracer.leave(currNode);
  Tracer.delay();
  // }
  // logger {
  logger.println(`In-degrees are: [${String(inDegrees)} ]`);
  logger.println('-------------------------------------------------------------------');
  // }
  
  iter++;
}

================
File: Brute Force/Binary Tree Traversal/inOrder.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const G = [ // G[i][j] indicates whether the path from the i-th node to the j-th node exists or not
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
];

const T = [ // mapping to G as a binary tree , [i][0] indicates left child, [i][1] indicates right child
  [-1, -1],
  [0, 2],
  [-1, -1],
  [1, 4],
  [-1, -1],
  [3, 8],
  [-1, 7],
  [-1, -1],
  [6, 10],
  [-1, -1],
  [9, -1],
];

// define tracer variables {
const treeTracer = new GraphTracer('Traversal In-order');
const arrayTracer = new Array1DTracer('Print In-order');
const logger = new LogTracer('Log');
Layout.setRoot(new VerticalLayout([treeTracer, arrayTracer, logger]));
treeTracer.set(G);
treeTracer.layoutTree(5);
arrayTracer.set(new Array(T.length).fill('-'));
Tracer.delay();
// }

let index = 0;

function inOrder(root, parent) {
  if (root === -1) {
    // logger {
    logger.println('No more nodes. Backtracking.');
    Tracer.delay();
    // }
    return;
  }

  // visualize {
  logger.println(`Reached ${root}`);
  treeTracer.visit(root, parent);
  Tracer.delay();

  logger.println(` Going left from ${root}`);
  Tracer.delay();
  // }
  inOrder(T[root][0], root);

  // visualize {
  logger.println(`Printing ${root}`);
  treeTracer.leave(root);
  arrayTracer.patch(index++, root);
  Tracer.delay();

  logger.println(` Going right from ${root}`);
  Tracer.delay();
  // }
  inOrder(T[root][1], root);
}

inOrder(5); // node with key 5 is the root
// logger {
logger.println('Finished');
// }

================
File: Brute Force/Binary Tree Traversal/postOrder.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const G = [ // G[i][j] indicates whether the path from the i-th node to the j-th node exists or not
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
];

const T = [ // mapping to G as a binary tree , [i][0] indicates left child, [i][1] indicates right child
  [-1, -1],
  [0, 2],
  [-1, -1],
  [1, 4],
  [-1, -1],
  [3, 8],
  [-1, 7],
  [-1, -1],
  [6, 10],
  [-1, -1],
  [9, -1],
];

// define tracer variables {
const treeTracer = new GraphTracer('Traversal Post-order');
const arrayTracer = new Array1DTracer('Print Post-order');
const logger = new LogTracer('Log');
Layout.setRoot(new VerticalLayout([treeTracer, arrayTracer, logger]));
treeTracer.set(G);
treeTracer.layoutTree(5);
arrayTracer.set(new Array(T.length).fill('-'));
Tracer.delay();
// }

let index = 0;

function postOrder(root, parent) {
  if (root === -1) {
    // logger {
    logger.println('No more nodes. Backtracking.');
    Tracer.delay();
    // }
    return;
  }

  // visualize {
  logger.println(`Reached ${root}`);
  treeTracer.visit(root, parent);
  Tracer.delay();

  logger.println(` Going left from ${root}`);
  Tracer.delay();
  // }
  postOrder(T[root][0], root);

  // logger {
  logger.println(` Going right from ${root}`);
  Tracer.delay();
  // }
  postOrder(T[root][1], root);

  // visualize {
  logger.println(`Printing ${root}`);
  treeTracer.leave(root);
  arrayTracer.patch(index++, root);
  Tracer.delay();
  // }
}

postOrder(5); // node with key 5 is the root
// logger {
logger.println('Finished');
// visualize {

================
File: Brute Force/Binary Tree Traversal/preOrder.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const G = [ // G[i][j] indicates whether the path from the i-th node to the j-th node exists or not
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
];

const T = [ // mapping to G as a binary tree , [i][0] indicates left child, [i][1] indicates right child
  [-1, -1],
  [0, 2],
  [-1, -1],
  [1, 4],
  [-1, -1],
  [3, 8],
  [-1, 7],
  [-1, -1],
  [6, 10],
  [-1, -1],
  [9, -1],
];

// define tracer variables {
const treeTracer = new GraphTracer('Traversal Pre-order');
const arrayTracer = new Array1DTracer('Print Pre-order');
const logger = new LogTracer('Log');
Layout.setRoot(new VerticalLayout([treeTracer, arrayTracer, logger]));
treeTracer.set(G);
treeTracer.layoutTree(5);
arrayTracer.set(new Array(T.length).fill('-'));
Tracer.delay();
// }

let index = 0;

function preOrder(root, parent) {
  if (root === -1) {
    // logger {
    logger.println('No more nodes. Backtracking.');
    Tracer.delay();
    // }
    return;
  }

  // visualize {
  logger.println(`Reached ${root}`);
  treeTracer.visit(root, parent);
  Tracer.delay();

  logger.println(`Printing ${root}`);
  treeTracer.leave(root);
  arrayTracer.patch(index++, root);
  Tracer.delay();

  logger.println(` Going left from ${root}`);
  Tracer.delay();
  // }
  preOrder(T[root][0], root);

  // logger {
  logger.println(` Going right from ${root}`);
  Tracer.delay();
  // }
  preOrder(T[root][1], root);
}

preOrder(5); // node with key 5 is the root
// logger {
logger.println('Finished');
// }

================
File: Brute Force/Bipartiteness Test/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const G = [
  [0, 1, 0, 1, 1],
  [1, 0, 1, 0, 0],
  [0, 1, 0, 1, 0],
  [1, 0, 1, 0, 0], // <-- replace latest 0 with 1 to make G not biparted
  [1, 0, 0, 0, 0],
];

// define tracer variables {
const tracer = new GraphTracer().directed(false);
const logger = new LogTracer();
tracer.log(logger);
tracer.set(G);
const colorsTracer = new Array1DTracer('Colors');
Layout.setRoot(new VerticalLayout([tracer, logger, colorsTracer]));
Tracer.delay();
// }

function BFSCheckBipartiteness(s) {
  const Q = [];

  // Create a new matrix to set colors (0,1)
  const Colors = [];
  for (let _i = 0; _i < G.length; _i++) Colors[_i] = -1;
  // visualize {
  colorsTracer.set(Colors);
  // }

  Colors[s] = 1;
  // visualize {
  colorsTracer.patch(s, 1);
  // }

  Q.push(s); // add start node to queue

  while (Q.length > 0) {
    const node = Q.shift(); // dequeue
    // visualize {
    tracer.visit(node);
    Tracer.delay();
    // }

    for (let i = 0; i < G[node].length; i++) {
      if (G[node][i]) {
        if (Colors[i] === -1) {
          Colors[i] = 1 - Colors[node];
          // visualize {
          colorsTracer.patch(i, 1 - Colors[node]);
          // }

          Q.push(i);
          // visualize {
          tracer.visit(i, node);
          Tracer.delay();
          // }
        } else if (Colors[i] === Colors[node]) {
          // logger {
          logger.println('Graph is not biparted');
          // }
          return false;
        }
      }
    }
  }

  // logger {
  logger.println('Graph is biparted');
  // }
  return true;
}

BFSCheckBipartiteness(0);

================
File: Brute Force/Breadth-First Search/shortestPath.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const tracer = new GraphTracer().directed(false).weighted();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.log(logger);
const G = Randomize.Graph({ N: 5, ratio: 1, directed: false, weighted: true });
tracer.set(G);
Tracer.delay();
// }

function BFS() {
  const W = []; // W[i] indicates the length of the shortest path from start node to the i-th node
  const Q = [];
  let i;
  for (i = 0; i < G.length; i++) {
    W.push(MAX_VALUE);
    // visualize {
    tracer.updateNode(i, MAX_VALUE);
    // }
  }
  W[s] = 0;
  Q.push(s); // add start node to queue
  // visualize {
  tracer.visit(s, undefined, 0);
  Tracer.delay();
  // }
  while (Q.length > 0) {
    const node = Q.shift(); // dequeue
    for (i = 0; i < G[node].length; i++) {
      if (G[node][i]) { // if the edge from current node to the i-th node exists
        if (W[i] > W[node] + G[node][i]) { // if current path is shorter than the previously shortest path
          W[i] = W[node] + G[node][i]; // update the length of the shortest path
          Q.push(i); // add child node to queue
          // visualize {
          tracer.visit(i, node, W[i]);
          Tracer.delay();
          // }
        }
      }
    }
  }
  return W[e];
}

let s = Randomize.Integer({ min: 0, max: G.length - 1 }); // s = start node
let e; // e = start node
do {
  e = Randomize.Integer({ min: 0, max: G.length - 1 });
} while (s === e);
let MAX_VALUE = 0x7fffffff;
// logger {
logger.println(`finding the shortest path from ${s} to ${e}`);
// }
const minWeight = BFS(s);
// logger {
if (minWeight === MAX_VALUE) {
  logger.println(`there is no path from ${s} to ${e}`);
} else {
  logger.println(`the shortest path from ${s} to ${e} is ${minWeight}`);
}
// }

================
File: Brute Force/Breadth-First Search/tree.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const G = [ // G[i][j] indicates whether the path from the i-th node to the j-th node exists or not
  [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
];

// define tracer variables {
const tracer = new GraphTracer();
const logger = new LogTracer();
tracer.log(logger);
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.set(G);
tracer.layoutTree(0);
Tracer.delay();
// }

function BFS(s) { // s = start node
  const Q = [];
  Q.push(s); // add start node to queue
  // visualize {
  tracer.visit(s);
  Tracer.delay();
  // }
  while (Q.length > 0) {
    const node = Q.shift(); // dequeue
    for (let i = 0; i < G[node].length; i++) {
      if (G[node][i]) { // if current node has the i-th node as a child
        Q.push(i); // add child node to queue
        // visualize {
        tracer.visit(i, node);
        Tracer.delay();
        // }
      }
    }
  }
}

BFS(0);

================
File: Brute Force/Bridge Finding/efficient.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const G = [
  [0, 1, 0, 0, 1, 0],
  [1, 0, 0, 0, 1, 0],
  [0, 0, 0, 1, 0, 0],
  [0, 0, 1, 0, 1, 1],
  [1, 1, 0, 1, 0, 0],
  [0, 0, 0, 1, 0, 0],
];

// define tracer variables {
const graphTracer = new GraphTracer().directed(false);
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([graphTracer, logger]));
graphTracer.set(G);
Tracer.delay();
// }

/*
  NOTE: Code assumes NO parallel edges
*/

let timer = 0; // adj keeps track of the neighbors of each node

const bridges = [];
const adj = [];

const util = (u, disc, low, parent) => {
  // u is the node that is currently being processed in the DFS (depth-first search)
  // disc is the numbering of the vertices in the DFS, starting at 0
  // low[v] is the lowest numbered vertex that can be reached from vertex v along the DFS
  // parent is the node that u came from
  // visualize {
  logger.println('');
  logger.println(`Visiting node ${u}`);
  graphTracer.visit(u);
  Tracer.delay();
  graphTracer.leave(u);
  Tracer.delay();
  // }

  // visited [u] = true;
  disc[u] = low[u] = timer++;

  // logger {
  logger.println(`Nodes adjacent to ${u} are: [ ${adj[u]} ]`);
  // }
  /* adj [u].forEach (function (v) {
    graphTracer.visit (v, u).delay ();
    graphTracer.leave (v, u).delay ();
  }); */
  const trace = (v) => {
    // visualize {
    graphTracer.visit(v, u);
    Tracer.delay();
    graphTracer.leave(v, u);
    Tracer.delay();
    // }
  };

  adj[u].forEach((v) => {
    if (disc[v] > -1 && v === parent) {
      trace(v);
      // logger {
      logger.println(`${u}'s neighbor ${v} is u's parent. Not visiting it.`);
      // }
    } else if (disc[v] > -1 && v !== parent) {
      trace(v);
      // logger {
      logger.println(`${u}'s neighbor ${v} is not u's parent. Comparing low[u] with disc[v]`);
      // }
      if (low[u] > disc[v]) {
        // logger {
        logger.println(`low[${u}] is greater than disc[${v}]. Setting low[${u}] to disc[${v}]`);
        // }
        low[u] = disc[v];
      }
    }

    if (disc[v] === -1) {
      trace(v);
      // logger {
      logger.println(`${u}'s neighbor ${v} has not been visited yet`);

      logger.println(`recursively calling util (${v}, [${disc}], [${low}],${u})`);
      // }
      util(v, disc, low, u);

      // logger {
      logger.println('--------------------------------------------------------------------');

      logger.println(`Setting low [${u}] to ${Math.min(low[u], low[v])}`);
      // }
      low[u] = Math.min(low[u], low[v]);

      if (low[v] === disc[v]) {
        // logger {
        logger.println(`low [${v}] === disc [${v}], low[${v}]=${low[v]}, disc[${v}]=${disc[v]}`);
        logger.println(`${u} -> ${v} is a bridge. Adding ${u}->${v}to the set of bridges found`);
        // }
        bridges.push([u, v]);
      }
    }
  });
};

(function findBridges(graph) {
  const disc = filledArray(graph.length, -1);
  const low = filledArray(graph.length, -1);

  function filledArray(length, value) {
    return Array(...Array(length)).map(Number.prototype.valueOf, value);
  }

  // PRECOMPUTATION: store every node's neighbor info in auxiliary array for efficient retrieval later
  (function computeAdj() {
    graph.forEach((config) => {
      const temp = [];
      config.forEach((isEdge, i) => {
        isEdge && temp.push(i);
      });
      adj.push(temp);
    });
  }());

  // logger {
  logger.println(`Initializing: <b>disc</b>: ${disc} <b>low</b>: ${low}`);
  logger.println('');
  logger.println('Beginning efficient Bridge Finding');
  logger.println('NOTE: call to util () follows pattern: util (nodeToVisit, disc, low, parent). See code for clarity');
  logger.println('');

  logger.println('Starting the main for loop (for each node)');
  // }
  for (let v = 0; v < graph.length; v++) {
    if (disc[v] === -1) {
      // logger {
      logger.println(`${v} has not been visited yet. Calling util (${v},  [${disc}], [${low}],${v}) from the for loop`);
      // }
      util(v, disc, low, v);
      // logger {
      logger.println(`Returned in for loop after util (${v}, [${disc}], [${low}], [${v}])`);
      // }
    }
  }
}(G));

// logger {
logger.println(`There are ${bridges.length} bridges in the Graph`);
for (let i = 0; i < bridges.length; i++) {
  logger.println(`${bridges[i][0]}-->${bridges[i][1]}`);
}
logger.println('NOTE: All bridges are both ways (just like in the Naive Algorithm) because the Graph is undirected. So, edge A->B and B->A, both are bridges');
// }

================
File: Brute Force/Bridge Finding/naive.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const G = [
  [0, 1, 0, 0, 0, 0],
  [1, 0, 0, 1, 1, 0],
  [0, 0, 0, 1, 0, 0],
  [0, 1, 1, 0, 1, 1],
  [0, 1, 0, 1, 0, 0],
  [0, 0, 0, 1, 0, 0],
];

// define tracer variables {
const tracer = new GraphTracer().directed(false);
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.set(G);
Tracer.delay();
// }

// Depth First Search Exploration Algorithm to test connectedness of the Graph (see Graph Algorithms/DFS/exploration), without the tracer & logger commands
function DFSExplore(graph, source) {
  const stack = [[source, null]];
  const visited = {};
  let node;
  let prev;
  let i;
  let temp;

  while (stack.length > 0) {
    temp = stack.pop();
    node = temp[0];
    prev = temp[1];

    if (!visited[node]) {
      visited[node] = true;

      for (i = 0; i < graph.length; i++) {
        if (graph[node][i]) {
          stack.push([i, node]);
        }
      }
    }
  }

  return visited;
}

function findBridges(graph) {
  let tempGraph;
  const bridges = [];
  let visited;

  for (let i = 0; i < graph.length; i++) {
    for (let j = 0; j < graph.length; j++) {
      if (graph[i][j]) { // check if an edge exists
        // visualize {
        logger.println(`Deleting edge ${i}->${j} and calling DFSExplore ()`);
        tracer.visit(j, i);
        Tracer.delay();
        tracer.leave(j, i);
        Tracer.delay();
        // }

        tempGraph = JSON.parse(JSON.stringify(graph));
        tempGraph[i][j] = 0;
        tempGraph[j][i] = 0;
        visited = DFSExplore(tempGraph, 0);

        if (Object.keys(visited).length === graph.length) {
          // logger {
          logger.println('Graph is CONNECTED. Edge is NOT a bridge');
          // }
        } else {
          // logger {
          logger.println('Graph is DISCONNECTED. Edge IS a bridge');
          // }
          bridges.push([i, j]);
        }
      }
    }
  }

  return bridges;
}

const bridges = findBridges(G);

// logger {
logger.println('The bridges are: ');
for (const i in bridges) {
  logger.println(`${bridges[i][0]} to ${bridges[i][1]}`);
}
logger.println('NOTE: A bridge is both ways, i.e., from A to B and from B to A, because this is an Undirected Graph');
// }

================
File: Brute Force/Bubble Sort/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const chart = new ChartTracer();
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([chart, tracer, logger]));
const D = Randomize.Array1D({ N: 15 });
tracer.set(D);
tracer.chart(chart);
Tracer.delay();
// }

// logger {
logger.println(`original array = [${D.join(', ')}]`);
// }
let N = D.length;
let swapped;
do {
  swapped = false;
  // visualize {
  tracer.select(N - 1);
  Tracer.delay();
  // }
  for (let i = 1; i < N; i++) {
    // visualize {
    tracer.select(i);
    Tracer.delay();
    // }
    if (D[i - 1] > D[i]) {
      // logger {
      logger.println(`swap ${D[i - 1]} and ${D[i]}`);
      // }
      const temp = D[i - 1];
      D[i - 1] = D[i];
      D[i] = temp;
      swapped = true;
      // visualize {
      tracer.patch(i - 1, D[i - 1]);
      tracer.patch(i, D[i]);
      Tracer.delay();
      tracer.depatch(i - 1);
      tracer.depatch(i);
      // }
    }
    // visualize {
    tracer.deselect(i);
    // }
  }
  // visualize {
  tracer.deselect(N - 1);
  // }
  N--;
} while (swapped);
// logger {
logger.println(`sorted array = [${D.join(', ')}]`);
// }

================
File: Brute Force/Comb Sort/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const chart = new ChartTracer();
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([chart, tracer, logger]));
const D = Randomize.Array1D({ N: 15 });
tracer.set(D);
tracer.chart(chart);
Tracer.delay();
// }

// logger {
logger.println(`original array = [${D.join(', ')}]`);
// }
const N = D.length;
let swapped;
let gap = N; // initialize gap size
const shrink = 1.3; // set the gap shrink factor

do {
  // update the gap value for the next comb.
  gap = Math.floor(gap / shrink);
  if (gap < 1) {
    // minimum gap is 1
    gap = 1;
  }

  swapped = false; // initialize swapped
  // a single comb over the input list
  for (let i = 0; i + gap < N; i++) {
    // visualize {
    tracer.select(i);
    tracer.select(i + gap);
    Tracer.delay();
    // }

    if (D[i] > D[i + gap]) {
      // logger {
      logger.println(`swap ${D[i]} and ${D[i + gap]}`); // log swap event
      // }
      
      const temp = D[i];
      D[i] = D[i + gap];
      D[i + gap] = temp;

      // visualize {
      tracer.patch(i, D[i]);
      tracer.patch(i + gap, D[i + gap]);
      Tracer.delay();
      tracer.depatch(i);
      tracer.depatch(i + gap);
      // }

      swapped = true; // Flag swapped has happened and list is not guaranteed sorted
    }
    // visualize {
    tracer.deselect(i);
    tracer.deselect(i + gap);
    // }
  } // End of combing
} while (gap !== 1 || swapped);

================
File: Brute Force/Cycle Sort/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const chart = new ChartTracer();
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([chart, tracer, logger]));
const D = Randomize.Array1D({ N: 15 });
tracer.set(D);
tracer.chart(chart);
Tracer.delay();
// }

// logger {
logger.println(`original array = [${D.join(', ')}]`);
// }
const N = D.length;
let writes = 0; // number of writing performed
let pos; // the index of item in the sorted array
let item; // an item in the array
let temp; // a temp value used for storing swapped item
for (let cycleStart = 0; cycleStart <= N - 2; cycleStart++) {
  item = D[cycleStart];

  // find where to put the item
  pos = cycleStart;
  // visualize {
  tracer.select(cycleStart);
  // }

  for (let i = cycleStart + 1; i <= N - 1; i++) {
    // visualize {
    tracer.select(i);
    Tracer.delay();
    tracer.deselect(i);
    // }
    if (D[i] < item) {
      pos++;
    }
  }

  // if the item is already there, this is not a circle
  if (pos === cycleStart) {
    // visualize {
    tracer.deselect(cycleStart);
    // }
    continue;
  }

  // otherwise put the item there or right after any duplicates
  while (item === D[pos]) {
    pos++;
  }

  // write item to new index and increment writes
  temp = D[pos];
  D[pos] = item;
  item = temp;

  writes++;

  // logger {
  if (pos !== cycleStart) {
    logger.println(`Rewrite ${D[pos]} to index ${pos}; the next value to rewrite is ${item}`);
  } else {
    logger.println(`Rewrite ${D[pos]} to index ${pos}`);
  }
  // }
  // visualize {
  tracer.select(pos);
  Tracer.delay();
  tracer.deselect(pos);
  tracer.patch(pos, D[pos]);
  tracer.patch(cycleStart, D[cycleStart]);
  Tracer.delay();
  tracer.depatch(pos);
  tracer.depatch(cycleStart);
  // }

  // rotate the rest of the cycle
  while (pos !== cycleStart) {
    pos = cycleStart;

    for (let i = cycleStart + 1; i <= N - 1; i++) {
      // visualize {
      tracer.select(i);
      Tracer.delay();
      tracer.deselect(i);
      // }
      if (D[i] < item) {
        pos++;
      }
    }

    while (item === D[pos]) {
      pos++;
    }

    temp = D[pos];
    D[pos] = item;
    item = temp;

    // logger {
    if (pos !== cycleStart) {
      logger.println(`Rewrite ${D[pos]} to index ${pos}; the next value to rewrite is ${item}`);
    } else {
      logger.println(`Rewrite ${D[pos]} to index ${pos}`);
    }
    // }
    // visualize {
    tracer.select(pos);
    Tracer.delay();
    tracer.deselect(pos);
    tracer.patch(pos, D[pos]);
    tracer.patch(cycleStart, D[cycleStart]);
    Tracer.delay();
    tracer.depatch(pos);
    tracer.depatch(cycleStart);
    // }

    writes++;
  }
}

// logger {
logger.println(`Number of writes performed is ${writes}`);
// }

================
File: Brute Force/Depth-First Search/graph.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const graphTracer = new GraphTracer().directed(false);
const visitedTracer = new Array1DTracer('visited');
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([graphTracer, visitedTracer, logger]));
graphTracer.log(logger);
const G = Randomize.Graph({ N: 8, ratio: .3, directed: false });
graphTracer.set(G);
Tracer.delay();
// }

function DFSExplore(graph, source) {
  const stack = [[source, null]];
  const visited = [];
  let node;
  let prev;
  let i;
  let temp;
  for (i = 0; i < graph.length; i++) {
    visited.push(false);
  }
  // visualize {
  visitedTracer.set(visited);
  // }

  while (stack.length > 0) {
    temp = stack.pop();
    node = temp[0];
    prev = temp[1];

    if (!visited[node]) {
      visited[node] = true;
      // visualize {
      visitedTracer.patch(node, visited[node]);

      if (prev !== undefined && graph[node][prev]) {
        graphTracer.visit(node, prev);
        Tracer.delay();
      } else {
        graphTracer.visit(node);
        Tracer.delay();
      }
      // }

      for (i = 0; i < graph.length; i++) {
        if (graph[node][i]) {
          stack.push([i, node]);
        }
      }
    }
  }

  return visited;
}

const visited = DFSExplore(G, 0);
let check = true;
for (let i = 0; i < visited.length; i++) check &= visited[i];
// logger {
if (check) {
  logger.println('The Graph is CONNECTED');
} else {
  logger.println('The Graph is NOT CONNECTED');
}
// }

================
File: Brute Force/Depth-First Search/shortestPath.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const tracer = new GraphTracer().directed(false).weighted();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.log(logger);
const G = Randomize.Graph({ N: 5, ratio: 1, directed: false, weighted: true });
tracer.set(G);
Tracer.delay();
// }

function DFS(node, parent, weight) { // node = current node, parent = previous node
  if (minWeight < weight) return;
  if (node === e) {
    // visualize {
    tracer.visit(node, parent, weight);
    Tracer.delay();
    // }
    if (minWeight > weight) {
      minWeight = weight;
    }
    // visualize {
    tracer.leave(node, parent, minWeight);
    Tracer.delay();
    // }
    return;
  }
  D[node] = true; // label current node as discovered
  // visualize {
  tracer.visit(node, parent, weight);
  Tracer.delay();
  // }
  for (let i = 0; i < G[node].length; i++) {
    if (G[node][i]) { // if the path from current node to the i-th node exists
      if (!D[i]) { // if the i-th node is not labeled as discovered
        DFS(i, node, weight + G[node][i]); // recursively call DFS
      }
    }
  }
  D[node] = false; // label current node as undiscovered
  // visualize {
  tracer.leave(node, parent, 0);
  Tracer.delay();
  // }
}

const s = Randomize.Integer({ min: 0, max: G.length - 1 }); // s = start node
let e; // e = end node
do {
  e = Randomize.Integer({ min: 0, max: G.length - 1 });
} while (s === e);
const MAX_VALUE = Infinity;
let minWeight = MAX_VALUE;
// logger {
logger.println(`finding the shortest path from ${s} to ${e}`);
// }
let D = []; // D[i] indicates whether the i-th node is discovered or not
for (let i = 0; i < G.length; i++) D.push(false);
DFS(s, undefined, 0);
// logger {
if (minWeight === MAX_VALUE) {
  logger.println(`there is no path from ${s} to ${e}`);
} else {
  logger.println(`the shortest path from ${s} to ${e} is ${minWeight}`);
}
// }

================
File: Brute Force/Depth-First Search/tree.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const G = [ // G[i][j] indicates whether the path from the i-th node to the j-th node exists or not
  [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
];

// define tracer variables {
const tracer = new GraphTracer();
const logger = new LogTracer();
tracer.log(logger);
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.set(G);
tracer.layoutTree(0);
Tracer.delay();
// }

function DFS(node, parent) { // node = current node, parent = previous node
  // visualize {
  tracer.visit(node, parent);
  Tracer.delay();
  // }
  for (let i = 0; i < G[node].length; i++) {
    if (G[node][i]) { // if current node has the i-th node as a child
      DFS(i, node); // recursively call DFS
    }
  }
}

DFS(0);

================
File: Brute Force/Depth-First Search/weightedGraph.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const tracer = new GraphTracer().directed(false).weighted();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.log(logger);
const G = Randomize.Graph({ N: 5, ratio: 1, directed: false, weighted: true });
tracer.set(G);
Tracer.delay();
// }

let D; // D[i] indicates whether the i-th node is discovered or not

function DFS(node, parent, weight) { // node = current node, parent = previous node
  // visualize {
  tracer.visit(node, parent, weight);
  Tracer.delay();
  // }
  D[node] = true; // label current node as discovered
  for (let i = 0; i < G[node].length; i++) {
    if (G[node][i]) { // if the edge from current node to the i-th node exists
      if (!D[i]) { // if the i-th node is not labeled as discovered
        DFS(i, node, weight + G[node][i]); // recursively call DFS
      }
    }
  }
  D[node] = false; // label current node as undiscovered
  // visualize {
  tracer.leave(node, parent, 0);
  Tracer.delay();
  // }
}

for (let i = 0; i < G.length; i++) { // start from every node
  // logger {
  logger.println(`start from ${i}`);
  // }
  D = [];
  for (let j = 0; j < G.length; j++) D.push(false);
  DFS(i, undefined, 0);
}

================
File: Brute Force/Flood Fill/code.js
================
// import visualization libraries {
const { Tracer, Array2DTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const G = [
  ['#', '#', '#', '#', '#', '#', '#', '#', '#'],
  ['#', '-', '-', '-', '#', '-', '-', '-', '#'],
  ['#', '-', '-', '-', '#', '-', '-', '-', '#'],
  ['#', '-', '-', '#', '-', '-', '-', '-', '#'],
  ['#', '#', '#', '-', '-', '-', '#', '#', '#'],
  ['#', '-', '-', '-', '-', '#', '-', '-', '#'],
  ['#', '-', '-', '-', '#', '-', '-', '-', '#'],
  ['#', '-', '-', '-', '#', '-', '-', '-', '#'],
  ['#', '#', '#', '#', '#', '#', '#', '#', '#'],
];

// define tracer variables {
const tracer = new Array2DTracer();
Layout.setRoot(new VerticalLayout([tracer]));
tracer.set(G);
Tracer.delay();
// }

function FloodFill(i, j, oldColor, newColor) {
  if (i < 0 || i >= G.length || j < 0 || j >= G[i].length) return;
  if (G[i][j] !== oldColor) return;

  // set the color of node to newColor
  G[i][j] = newColor;

  // visualize {
  tracer.select(i, j);
  Tracer.delay();
  tracer.patch(i, j, G[i][j]);
  Tracer.delay();
  // }

  // next step four-way
  FloodFill(i + 1, j, oldColor, newColor);
  FloodFill(i - 1, j, oldColor, newColor);
  FloodFill(i, j + 1, oldColor, newColor);
  FloodFill(i, j - 1, oldColor, newColor);
}

FloodFill(4, 4, '-', 'a');

================
File: Brute Force/Heapsort/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const chart = new ChartTracer();
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([chart, tracer, logger]));
const D = Randomize.Array1D({ N: 10 });
tracer.set(D);
tracer.chart(chart);
Tracer.delay();
// }

// logger {
logger.println(`Original array = [${D.join(', ')}]`);
// }

function heapSort(array, size) {
  let i;
  let j;
  let temp;

  for (i = Math.floor(size / 2) - 1; i >= 0; i--) {
    heapify(array, size, i);
  }

  for (j = size - 1; j >= 0; j--) {
    temp = array[0];
    array[0] = array[j];
    array[j] = temp;

    // visualize {
    tracer.patch(0, array[0]);
    tracer.patch(j, array[j]);
    logger.println(`Swapping elements : ${array[0]} & ${array[j]}`);
    Tracer.delay();
    tracer.depatch(0);
    tracer.depatch(j);
    tracer.select(j);
    Tracer.delay();
    // }

    heapify(array, j, 0);

    // visualize {
    tracer.deselect(j);
    // }
  }
}

function heapify(array, size, root) {
  let largest = root;
  const left = 2 * root + 1;
  const right = 2 * root + 2;
  let temp;

  if (left < size && array[left] > array[largest]) {
    largest = left;
  }

  if (right < size && array[right] > array[largest]) {
    largest = right;
  }

  if (largest !== root) {
    temp = array[root];
    array[root] = array[largest];
    array[largest] = temp;

    // visualize {
    tracer.patch(root, array[root]);
    tracer.patch(largest, array[largest]);
    logger.println(`Swapping elements : ${array[root]} & ${array[largest]}`);
    Tracer.delay();
    tracer.depatch(root);
    tracer.depatch(largest);
    // }

    heapify(array, size, largest);
  }
}

heapSort(D, D.length);

// logger {
logger.println(`Final array = [${D.join(', ')}]`);
// }

================
File: Brute Force/Insertion Sort/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const chart = new ChartTracer();
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([chart, tracer, logger]));
const D = Randomize.Array1D({ N: 15 });
tracer.set(D);
tracer.chart(chart);
Tracer.delay();
// }

// logger {
logger.println(`original array = [${D.join(', ')}]`);
// }
for (let i = 1; i < D.length; i++) {
  const key = D[i];
  // visualize {
  logger.println(`insert ${key}`);
  tracer.select(i);
  Tracer.delay();
  // }
  let j;
  for (j = i - 1; (j >= 0) && (D[j] > key); j--) {
    D[j + 1] = D[j];
    // visualize {
    tracer.patch(j + 1, D[j + 1]);
    Tracer.delay();
    tracer.depatch(j + 1);
    // }
  }
  D[j + 1] = key;
  // visualize {
  tracer.patch(j + 1, D[j + 1]);
  Tracer.delay();
  tracer.depatch(j + 1);
  tracer.deselect(i);
  // }
}
// logger {
logger.println(`sorted array = [${D.join(', ')}]`);
// }

================
File: Brute Force/Lowest Common Ancestor/code.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const G = [ // G[i][j] indicates whether the path from the i-th node to the j-th node exists or not
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
  [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
];

const T = [ // mapping to G as a binary tree , [i][0] indicates left child, [i][1] indicates right child
  [-1, -1],
  [-1, 7],
  [-1, -1],
  [6, 1],
  [-1, -1],
  [3, 8],
  [0, 2],
  [-1, -1],
  [10, 4],
  [-1, -1],
  [9, -1],
];

// define tracer variables {
const treeTracer = new GraphTracer(' Traversal Pre-order ');
const logger = new LogTracer(' Log ');
Layout.setRoot(new VerticalLayout([treeTracer, logger]));
treeTracer.set(G);
treeTracer.layoutTree(5);
Tracer.delay();
// }

function lcaBT(parent, root, a, b) {
  // logger {
  logger.println(`Beginning new Iteration of lcaBT () with parent: ${parent}, current root: ${root}`);
  // }
  if (root === -1) {
    // logger {
    logger.println('Reached end of path & target node(s) not found');
    // }
    return null;
  }

  // visualize {
  if (parent !== null) treeTracer.visit(root, parent);
  else treeTracer.visit(root);
  Tracer.delay();
  // visualize {

  if (root === a || root === b) return root;

  const left = lcaBT(root, T[root][0], a, b);
  const right = lcaBT(root, T[root][1], a, b);

  if (left !== null && right !== null) return root;
  if (left === null && right === null) {
    // visualize {
    treeTracer.leave(root, parent);
    Tracer.delay();
    // }
  }

  return (left !== null ? left : right);
}

const a = 7;
const b = 2;
// logger {
logger.println(`Lowest common ancestor of ${a} & ${b} is: ${lcaBT(null, 5, a, b)}`);
// }

================
File: Brute Force/PageRank/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Array2DTracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

function filledArray(length, value) {
  return Array(...Array(length)).map(Number.prototype.valueOf, value);
}

// define tracer variables {
const G = Randomize.Graph({ N: 5, ratio: .4 });
let ranks;
const outgoingEdgeCounts = filledArray(G.length, 0);
let incomingNodes;
const graphTracer = new GraphTracer('Web Page inter-connections');
const rankTracer = new Array1DTracer('Web Page Ranks');
const oecTracer = new Array1DTracer('Outgoing Edge Counts');
const inTracer = new Array2DTracer('Incoming Nodes');

const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([graphTracer, rankTracer, oecTracer, inTracer, logger]));

graphTracer.set(G);
oecTracer.set(outgoingEdgeCounts);

for (incomingNodes = []; incomingNodes.length < G.length; incomingNodes.push(filledArray(G.length, -1))) ;
inTracer.set(incomingNodes);
Tracer.delay();
// }

/*
  PageRank Algorithm Version 2
  Equation:
    PR (X) = ( (1 - D)/N ) + D (Summation i->X (PR (I) / Out (i)))
  NOTE: Algorithm uses the recommended damping factor (D). Number of iterations is small because only a small Web of 5 Pages is simulated
*/

function arraySum(array) {
  return array.reduce(
    (sum, curr) =>
      sum + (curr ? 1 : 0) // if curr is 0 (no edge) or undefined (loop not allowed), sum remains unchanged
    , 0,
  );
}

function showOutgoingEdges(i) {
  G[i].forEach((edgeExists, j) => {
    if (edgeExists) {
      // visualize {
      graphTracer.visit(j, i);
      Tracer.delay();
      graphTracer.leave(j, i);
      Tracer.delay();
      // }
    }
  });
}

// PRECOMPUTATIONS

// logger {
logger.println('Calculate Outgoing Edge Count for each Node');
// }
(function calculateOEC() {
  G.forEach((relations, i) => {
    outgoingEdgeCounts[i] = arraySum(relations);
    showOutgoingEdges(i);

    // visualize {
    oecTracer.patch(i, outgoingEdgeCounts[i]);
    Tracer.delay();
    oecTracer.depatch(i);
    Tracer.delay();
    // }
  });
}());

// logger {
logger.println('determine incoming nodes for each node');
// }
(function determineIN() {
  for (let i = 0; i < G.length; i++) {
    for (let j = 0; j < G.length; j++) {
      if (G[i][j]) {
        // there's an edge FROM i TO j
        // visualize {
        graphTracer.visit(j, i);
        Tracer.delay();
        // }

        const nextPos = incomingNodes[j].indexOf(-1);
        incomingNodes[j][nextPos] = i;
        // visualize {
        inTracer.patch(j, nextPos, i);
        Tracer.delay();
        inTracer.depatch(j, nextPos);
        Tracer.delay();

        graphTracer.leave(j, i);
        Tracer.delay();
        // }
      }
    }
  }

  // logger.println ('All -1s will be removed from incoming node records, they are irrelevant');
  incomingNodes.forEach((arr) => {
    arr.splice(arr.indexOf(-1));
  });
}());

function updateRank(nodeIndex) {
  let inNodeSummation = 0;
  let result;

  // logger {
  logger.println(`Updating rank of ${nodeIndex}`);
  logger.println(`The incoming Nodes of ${nodeIndex} are being highlighted`);
  // }

  incomingNodes[nodeIndex].forEach((incoming, i) => {
    // visualize {
    inTracer.select(nodeIndex, i);
    Tracer.delay();
    logger.println(`Outgoing edge count of ${incoming} is ${outgoingEdgeCounts[incoming]}`);
    oecTracer.select(incoming);
    Tracer.delay();
    // }

    inNodeSummation += (ranks[incoming] / outgoingEdgeCounts[incoming]);

    // visualize {
    oecTracer.deselect(incoming);
    Tracer.delay();
    inTracer.deselect(nodeIndex, i);
    Tracer.delay();
    // }
  });
  // logger {
  logger.println(`In-Node summation of ${nodeIndex} = ${inNodeSummation}`);
  // }
  
  result = ((1 - damping) / G.length) + (damping * inNodeSummation); // notice the subtle difference between equations of Basic PR & PR version 2 (divide by N)
  // logger {
  logger.println(`Therefore, using Equation, new rank of ${nodeIndex} = ${result}`);
  // }
  return result;
}

let damping = 0.85;
let iterations = 7;
const initialRank = 1.0;

// logger {
logger.println(`Initialized all Page ranks to ${initialRank}`);
// }
ranks = filledArray(G.length, initialRank);

// visualize {
rankTracer.set(ranks);
// }
// logger {
logger.println('Begin execution of PageRank Version #1');
logger.println('Equation used: PR (X) = (1 - D) + D (In-Node-Summation i->X (PR (I) / Out (i)))');
logger.println('D = Damping Factor, PR (X) = Page rank of Node X, i = the ith In-Node of X, Out (i) = outgoing Edge Count of i');
logger.println('');
// }

while (iterations--) {
  for (let node = 0; node < ranks.length; node++) {
    ranks[node] = updateRank(node);
    // visualize {
    rankTracer.patch(node, ranks[node]);
    Tracer.delay();
    rankTracer.patch(node);
    Tracer.delay();
    // }
  }
}

// logger {
logger.println('Page Ranks have been converged to.');
ranks.forEach((rank, node) => {
  logger.println(`Rank of Node #${node} = ${rank}`);
});
logger.println('Done');
// }

================
File: Brute Force/Pancake Sort/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const chart = new ChartTracer();
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([chart, tracer, logger]));
const D = Randomize.Array1D({ N: 10 });
tracer.set(D);
tracer.chart(chart);
Tracer.delay();
// }

// logger {
logger.println(`original array = [${D.join(', ')}]`);
// }
const N = D.length;

function flip(start) {
  // visualize {
  tracer.select(start, N - 1);
  Tracer.delay();
  // }
  let idx = 0;
  for (let i = start; i < (start + N) / 2; i++) {
    // visualize {
    tracer.select(i);
    Tracer.delay();
    // }
    const temp = D[i];
    D[i] = D[N - idx - 1];
    D[N - idx - 1] = temp;
    // visualize {
    tracer.patch(i, D[i]);
    tracer.patch(N - idx - 1, D[N - idx - 1]);
    Tracer.delay();
    tracer.depatch(i);
    tracer.depatch(N - idx - 1);
    tracer.deselect(i);
    // }
    idx++;
  }
  // visualize {
  tracer.deselect(start, N - 1);
  // }
}

for (let i = 0; i < N - 1; i++) {
  // logger {
  logger.println(`round ${i + 1}`);
  // }
  const currArr = D.slice(i, N);
  const currMax = currArr.reduce((prev, curr, idx) => ((curr > prev.val) ? { idx, val: curr } : prev), {
    idx: 0,
    val: currArr[0],
  });
  if (currMax.idx !== 0) { // if currMax.idx === 0 that means max element already at the bottom, no flip required
    // logger {
    logger.println(`flip at ${currMax.idx + i} (step 1)`);
    // }
    flip(currMax.idx + i, N);
    // logger {
    logger.println(`flip at ${i} (step 2)`);
    // }
    flip(i, N);
  }
}

// logger {
logger.println(`sorted array = [${D.join(', ')}]`);
// }

================
File: Brute Force/Rabin-Karp's String Search/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const text = ['h', 'e', 'l', 'l', 'o', ' ', 's', 'i', 'r', ' ', 'h', 'e', 'l', 'l', 'o'];
const pattern = ['h', 'e', 'l', 'l', 'o'];

const Q = 101; // A prime number
const D = 256; // number of characters in the input alphabet

// define tracer variables {
const logger = new LogTracer();
const tracer1 = new Array1DTracer('Text');
const tracer2 = new Array1DTracer('Pattern');
Layout.setRoot(new VerticalLayout([logger, tracer1, tracer2]));
tracer1.set(text);
tracer2.set(pattern);
Tracer.delay();
// }

const N = text.length;
const M = pattern.length;

let hashText = 0; // hash value for text
let hashPattern = 0; // hash value for pattern
let h = 1;

for (let i = 0; i < (M - 1); i++) {
  h = (h * D) % Q;
}

for (let i = 0; i < M; i++) {
  hashPattern = (D * hashPattern + pattern[i].charCodeAt(0)) % Q;
  hashText = (D * hashText + text[i].charCodeAt(0)) % Q;
}

for (let i = 0; i <= N - M; i++) {
  /*
  Check if hash values of current window of text matches
  with hash values of pattern. If match is found then
  check for characters one by one
  */
  if (hashPattern === hashText) {
    let f = 0;
    // visualize {
    tracer1.select(i, i + M - 1);
    Tracer.delay();
    tracer2.select(0, M - 1);
    Tracer.delay();
    // }
    for (let j = 0; j < M; j++) {
      // visualize {
      tracer1.patch(i + j);
      Tracer.delay();
      tracer2.patch(j);
      Tracer.delay();
      // }
      if (text[i + j] !== pattern[j]) {
        f++;
      }
      // visualize {
      tracer1.depatch(i + j);
      tracer2.depatch(j);
      // }
    }

    // visualize {
    if (f === 0) {
      logger.println(` Pattern found at index ${i}`);
    }
    tracer1.deselect(i, i + M);
    tracer2.deselect(0, M - 1);
    // }
  }

  /*
  Calculate hash value for next window of text :
  */
  if (i < N - M) {
    hashText = (D * (hashText - text[i].charCodeAt(0) * h) + text[i + M].charCodeAt(0)) % Q;

    // Convert negative value of hashText (if found) to positive
    if (hashText < 0) {
      hashText += Q;
    }
  }
}

================
File: Brute Force/Selection Sort/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const chart = new ChartTracer();
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([chart, tracer, logger]));
const D = Randomize.Array1D({ N: 15 });
tracer.set(D);
tracer.chart(chart);
Tracer.delay();
// }

// logger {
logger.println(`original array = [${D.join(', ')}]`);
// }
for (let i = 0; i < D.length - 1; i++) {
  let minJ = i;
  // visualize {
  tracer.select(i);
  Tracer.delay();
  // }
  for (let j = i + 1; j < D.length; j++) {
    // visualize {
    tracer.select(j);
    Tracer.delay();
    // }
    if (D[j] < D[minJ]) {
      minJ = j;
      // visualize {
      tracer.patch(j);
      Tracer.delay();
      tracer.depatch(j);
      // }
    }
    // visualize {
    tracer.deselect(j);
    // }
  }
  if (minJ !== i) {
    // logger {
    logger.println(`swap ${D[i]} and ${D[minJ]}`);
    // }
    const temp = D[i];
    D[i] = D[minJ];
    D[minJ] = temp;
    // visualize {
    tracer.patch(i, D[i]);
    tracer.patch(minJ, D[minJ]);
    Tracer.delay();
    tracer.depatch(i);
    tracer.depatch(minJ);
    // }
  }
  // visualize {
  tracer.deselect(i);
  // }
}
// logger {
logger.println(`sorted array = [${D.join(', ')}]`);
// }

================
File: Brute Force/Shellsort/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const chart = new ChartTracer();
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([chart, tracer, logger]));
const D = Randomize.Array1D({ N: 15 });
tracer.set(D);
tracer.chart(chart);
Tracer.delay();
// }

// logger {
logger.println(`Original array = [${D.join(', ')}]`);
// }
const N = D.length;

for (let gap = N; gap = parseInt(gap / 2);) {
  // logger {
  logger.println('');
  logger.println(`Gap of ${gap}`);
  // }
  for (let i = gap; i < N; i++) {
    // visualize {
    tracer.select(i);
    tracer.select(i - gap);
    Tracer.delay();
    // }
    const k = D[i];
    // logger {
    logger.println(`Holding: ${k}`);
    // }
    let j;
    for (j = i; j >= gap && k < D[j - gap]; j -= gap) {
      // logger {
      logger.println(`${k} < ${D[j - gap]}`);
      // }
      D[j] = D[j - gap];
      // visualize {
      tracer.patch(j, D[j]);
      Tracer.delay();
      tracer.depatch(j);
      // }
    }
    const old = D[j];
    D[j] = k;
    // visualize {
    if (old !== k) {
      tracer.patch(j, D[j]);
      Tracer.delay();
      tracer.depatch(j);
      logger.println(`Swapped ${D[j]} with ${old}`);
    }

    tracer.deselect(i);
    tracer.deselect(i - gap);
    // }
  }
}
// logger {
logger.println('');
logger.println(`Sorted array = [${D.join(', ')}]`);
// }

================
File: Brute Force/Tarjan's Strongly Connected Components/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const G = [
  [0, 0, 1, 1, 0, 0],
  [1, 0, 0, 0, 0, 0],
  [0, 1, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0],
  [0, 0, 0, 0, 0, 1],
  [0, 0, 0, 0, 1, 0],
];

const disc = new Array(G.length);
const low = new Array(G.length);
const stackMember = new Array(G.length);
const st = [];
const carry = { time: 0 };

for (let i = 0; i < G.length; i++) {
  disc[i] = -1;
  low[i] = -1;
  stackMember[i] = false;
}

// define tracer variables {
const graphTracer = new GraphTracer();
graphTracer.set(G);
const discTracer = new Array1DTracer('Disc');
const lowTracer = new Array1DTracer('Low');
const stackMemberTracer = new Array1DTracer('stackMember');
const stTracer = new Array1DTracer('st');
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([graphTracer, discTracer, lowTracer, stackMemberTracer, stTracer, logger]));
discTracer.set(disc);
lowTracer.set(low);
stackMemberTracer.set(stackMember);
stTracer.set(st);
Tracer.delay();
// }

function SCCVertex(u, disc, low, st, stackMember, carry) {
  // visualize {
  graphTracer.visit(u);
  Tracer.delay();
  // }

  disc[u] = ++carry.time;
  // visualize {
  discTracer.patch(u, carry.time);
  Tracer.delay();
  // }

  low[u] = carry.time;
  // visualize {
  lowTracer.patch(u, carry.time);
  Tracer.delay();
  // }

  st.push(u);
  // visualize {
  stTracer.set(st);
  Tracer.delay();
  // }

  stackMember[u] = true;
  // visualize {
  stackMemberTracer.patch(u, true);
  Tracer.delay();
  // }

  // Go through all vertices adjacent to this
  for (let v = 0; v < G[u].length; v++) {
    if (G[u][v]) {
      // If v is not visited yet, then recur for it
      if (disc[v] === -1) {
        SCCVertex(v, disc, low, st, stackMember, carry);

        // Check if the subtree rooted with 'v' has a
        // connection to one of the ancestors of 'u'
        low[u] = Math.min(low[u], low[v]);
        // visualize {
        lowTracer.patch(u, low[u]);
        Tracer.delay();
        // }
      }

      // Update low value of 'u' only of 'v' is still in stack
      // (i.e. it's a back edge, not cross edge).
      else if (stackMember[v] === true) {
        low[u] = Math.min(low[u], disc[v]);
        // visualize {
        lowTracer.patch(u, low[u]);
        Tracer.delay();
        // }
      }
    }
  }

  // head node found, pop the stack and print an SCC
  let w = 0; // To store stack extracted vertices
  if (low[u] === disc[u]) {
    while (st[st.length - 1] !== u) {
      w = st.pop();
      // visualize {
      stTracer.set(st);
      Tracer.delay();

      logger.println(w);
      Tracer.delay();
      // }

      stackMember[w] = false;
      // visualize {
      stackMemberTracer.patch(w, false);
      Tracer.delay();
      // }
    }

    w = st.pop();
    // visualize {
    stTracer.set(st);
    Tracer.delay();

    logger.println(w);
    Tracer.delay();
    logger.println('------');
    // }

    stackMember[w] = false;
    // visualize {
    stackMemberTracer.patch(w, false);
    Tracer.delay();
    // }
  }
}

for (let i = 0; i < G.length; i++) {
  if (disc[i] === -1) {
    SCCVertex(i, disc, low, st, stackMember, carry);
  }
}

================
File: Divide and Conquer/Bucket Sort/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Array2DTracer, ChartTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const chartTracer = new ChartTracer('Chart');
const arrayTracer = new Array1DTracer('Array');
const bucketsTracer = new Array2DTracer('Buckets');
Layout.setRoot(new VerticalLayout([chartTracer, arrayTracer, bucketsTracer]));
// }

// define input variables
const N = 25; // the size of an array
const K = 5; // the number of buckets
const array = Randomize.Array1D({ N, value: () => Randomize.Integer({ min: 0, max: 999 }) });

(function main() {
  // create K buckets
  const buckets = [...new Array(K)].map(() => []);
  // visualize {
  arrayTracer.chart(chartTracer);
  arrayTracer.set(array);
  bucketsTracer.set(buckets);
  Tracer.delay();
  // }

  // find the maximum value that will be used for distribution
  const max = Math.max(...array);

  // distribute the elements into the buckets
  for (let i = 0; i < N; i++) {
    const number = array[i];
    const bucketIndex = Math.floor(number / (max + 1) * K);
    const bucket = buckets[bucketIndex];
    bucket.push(number);
    // visualize {
    arrayTracer.select(i);
    bucketsTracer.patch(bucketIndex, bucket.length - 1, number);
    Tracer.delay();
    bucketsTracer.depatch(bucketIndex, bucket.length - 1);
    // }

    // insertion sort within the bucket
    let j = bucket.length - 1;
    while (j > 0 && bucket[j - 1] > bucket[j]) {
      const temp = bucket[j - 1];
      bucket[j - 1] = bucket[j];
      bucket[j] = temp;
      // visualize {
      bucketsTracer.patch(bucketIndex, j - 1, bucket[j - 1]);
      bucketsTracer.patch(bucketIndex, j, bucket[j]);
      Tracer.delay();
      bucketsTracer.depatch(bucketIndex, j - 1);
      bucketsTracer.depatch(bucketIndex, j);
      // }
      j--;
    }
    // visualize {
    arrayTracer.deselect(i);
    // }
  }

  // concatenate the buckets back into the array
  let i = 0;
  for (let bucketIndex = 0; bucketIndex < K; bucketIndex++) {
    const bucket = buckets[bucketIndex];
    for (let j = 0; j < bucket.length; j++) {
      array[i] = bucket[j];
      // visualize {
      arrayTracer.patch(i, array[i]);
      bucketsTracer.select(bucketIndex, j);
      Tracer.delay();
      bucketsTracer.deselect(bucketIndex, j);
      arrayTracer.depatch(i);
      // }
      i++;
    }
  }
})();

================
File: Divide and Conquer/Counting Sort/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const arrayTracer = new Array1DTracer('Array');
const countsTracer = new Array1DTracer('Counts');
const sortedArrayTracer = new Array1DTracer('Sorted Array');
Layout.setRoot(new VerticalLayout([arrayTracer, countsTracer, sortedArrayTracer]));
// }

// define input variables
const N = 20; // the size of an array
const array = Randomize.Array1D({ N, value: () => Randomize.Integer({ min: 0, max: 9 }) });

(function main() {
  // find the maximum value that will decide the size of counts array
  const max = Math.max(...array);
  const counts = new Array(max + 1).fill(0);
  // visualize {
  arrayTracer.set(array);
  countsTracer.set(counts);
  Tracer.delay();
  // }

  // store counts of each number
  for (let i = 0; i < N; i++) {
    const number = array[i];
    counts[number]++;
    // visualize {
    arrayTracer.select(i);
    countsTracer.patch(number, counts[number]);
    Tracer.delay();
    countsTracer.depatch(number);
    arrayTracer.deselect(i);
    // }
  }

  // calculate the prefix sums
  for (let i = 1; i <= max; i++) {
    counts[i] += counts[i - 1];
    // visualize {
    countsTracer;
    countsTracer.select(i - 1);
    countsTracer.patch(i, counts[i]);
    Tracer.delay();
    countsTracer.depatch(i);
    countsTracer.deselect(i - 1);
    // }
  }

  // create a sorted array based on the prefix sums
  const sortedArray = new Array(N);
  // visualize {
  sortedArrayTracer.set(sortedArray);
  // }
  for (let i = N - 1; i >= 0; i--) {
    const number = array[i];
    const count = counts[number];
    sortedArray[count - 1] = number;
    counts[number]--;
    // visualize {
    arrayTracer.select(i);
    countsTracer.select(number);
    sortedArrayTracer.patch(count - 1, sortedArray[count - 1]);
    countsTracer.patch(number, counts[number]);
    Tracer.delay();
    sortedArrayTracer.depatch(count - 1);
    countsTracer.depatch(number);
    countsTracer.deselect(number);
    arrayTracer.deselect(i);
    // }
  }
})();

================
File: Divide and Conquer/Merge Sort/bottomUp.js
================
// import visualization libraries {
const { Tracer, Array2DTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const tracer = new Array2DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
const D = [
  Randomize.Array1D({ N: 20, value: () => Randomize.Integer({ min: 0, max: 50 }) }),
  Randomize.Array1D({ N: 20, value: () => Randomize.Integer({ min: 0, max: 0 }) }),
];

tracer.set(D);
Tracer.delay();
// }

// logger {
logger.println(`original array = [${D[0].join(', ')}]`);
// }

function mergeSort(start, end) {
  if (Math.abs(end - start) <= 1) return;

  let mergeFrom = 0;
  let mergeTo = 1;
  let width;
  let i;
  for (width = 1; width < end; width *= 2) {
    // visualize {
    logger.println(`merging arrays of width: ${width}`);
    // }
    for (i = 0; i < end; i += 2 * width) {
      merge(mergeFrom, i, Math.min(i + width, end), Math.min(i + 2 * width, end), mergeTo);
    }
    // this could be copy(mergeTo, mergeFrom, start, end);
    // but it is more effecient to swap the input arrays
    // if you did copy here, you wouldn't need the copy at the end
    mergeFrom = (mergeFrom === 0 ? 1 : 0);
    mergeTo = 1 - mergeFrom;
  }
  if (mergeFrom !== 0) {
    // visualize {
    logger.println('final copy to original');
    // }
    copy(mergeFrom, mergeTo, start, end);
  }
}

function merge(mergeFrom, start, middle, end, mergeTo) {
  let i = start;
  let j = middle;
  let k;
  // in an actual merge implementation, mergeFrom and mergeTo would be arrays
  // here for the ability to trace what is going on better, the arrays are D[mergeFrom] and D[mergeTo]
  // visualize {
  logger.println(`merging segments [${start}..${middle}] and [${middle}..${end}]`);
  tracer.selectRow(mergeFrom, start, end - 1);
  Tracer.delay();
  tracer.deselectRow(mergeFrom, start, end - 1);
  // }

  for (k = start; k < end; k++) {
    // visualize {
    if (j < end) {
      tracer.select(mergeFrom, j);
    }
    if (i < middle) {
      tracer.select(mergeFrom, i);
    }
    if (i < middle && j < end) {
      logger.println(`compare index ${i} and ${j}, values: ${D[mergeFrom][i]} and ${D[mergeFrom][j]}`);
      Tracer.delay();
    }
    // }

    if (i < middle && (j >= end || D[mergeFrom][i] <= D[mergeFrom][j])) {
      // visualize {
      if (j < end) {
        logger.println('writing smaller value to output');
      } else {
        logger.println(`copying index ${i} to output`);
      }
      tracer.patch(mergeTo, k, D[mergeFrom][i]);
      Tracer.delay();
      tracer.depatch(mergeTo, k);
      tracer.deselect(mergeFrom, i);
      // }

      D[mergeTo][k] = D[mergeFrom][i];
      i += 1;
    } else {
      // visualize {
      if (i < middle) {
        logger.println('writing smaller value to output');
      } else {
        logger.println(`copying index ${j} to output`);
      }
      tracer.patch(mergeTo, k, D[mergeFrom][j]);
      Tracer.delay();
      tracer.depatch(mergeTo, k);
      tracer.deselect(mergeFrom, j);
      // }

      D[mergeTo][k] = D[mergeFrom][j];
      j += 1;
    }
  }
}

function copy(mergeFrom, mergeTo, start, end) {
  let i;
  for (i = start; i < end; i++) {
    // visualize {
    tracer.select(mergeFrom, i);
    tracer.patch(mergeTo, i, D[mergeFrom][i]);
    Tracer.delay();
    // }

    D[mergeTo][i] = D[mergeFrom][i];

    // visualize {
    tracer.deselect(mergeFrom, i);
    tracer.depatch(mergeTo, i);
    // }
  }
}

mergeSort(0, D[0].length);
// logger {
logger.println(`sorted array = [${D[0].join(', ')}]`);
// }

================
File: Divide and Conquer/Merge Sort/topDown.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const chart = new ChartTracer();
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([chart, tracer, logger]));
const D = Randomize.Array1D({ N: 15 });
tracer.set(D);
tracer.chart(chart);
Tracer.delay();
// }

// logger {
logger.println(`original array = [${D.join(', ')}]`);
// }

function mergeSort(start, end) {
  if (Math.abs(end - start) <= 1) return [];
  const middle = Math.ceil((start + end) / 2);

  mergeSort(start, middle);
  mergeSort(middle, end);

  // logger {
  logger.println(`divide left[${start}, ${middle - 1}], right[${middle}, ${end - 1}]`);
  // }
  return mergeSort.merge(start, middle, end);
}

mergeSort.merge = (start, middle, end) => {
  const leftSize = middle - start;
  const rightSize = end - middle;
  const maxSize = Math.max(leftSize, rightSize);
  const size = end - start;
  const left = [];
  const right = [];
  let i;

  for (i = 0; i < maxSize; i++) {
    if (i < leftSize) {
      left.push(D[start + i]);
      // visualize {
      tracer.select(start + i);
      logger.println(`insert value into left array[${i}] = ${D[start + i]}`);
      Tracer.delay();
      // }
    }
    if (i < rightSize) {
      right.push(D[middle + i]);
      // visualize {
      tracer.select(middle + i);
      logger.println(`insert value into right array[${i}] = ${D[middle + i]}`);
      Tracer.delay();
      // }
    }
  }
  // logger {
  logger.println(`left array = [${left.join(', ')}], ` + `right array = [${right.join(', ')}]`);
  // }

  i = 0;
  while (i < size) {
    if (left[0] && right[0]) {
      if (left[0] > right[0]) {
        D[start + i] = right.shift();
        // logger {
        logger.println(`rewrite from right array[${i}] = ${D[start + i]}`);
        // }
      } else {
        D[start + i] = left.shift();
        // logger {
        logger.println(`rewrite from left array[${i}] = ${D[start + i]}`);
        // }
      }
    } else if (left[0]) {
      D[start + i] = left.shift();
      // logger {
      logger.println(`rewrite from left array[${i}] = ${D[start + i]}`);
      // }
    } else {
      D[start + i] = right.shift();
      // logger {
      logger.println(`rewrite from right array[${i}] = ${D[start + i]}`);
      // }
    }

    // visualize {
    tracer.deselect(start + i);
    tracer.patch(start + i, D[start + i]);
    Tracer.delay();
    tracer.depatch(start + i);
    // }
    i++;
  }

  const tempArray = [];
  for (i = start; i < end; i++) tempArray.push(D[i]);
  // logger {
  logger.println(`merged array = [${tempArray.join(', ')}]`);
  // }
};

mergeSort(0, D.length);
// logger {
logger.println(`sorted array = [${D.join(', ')}]`);
// }

================
File: Divide and Conquer/Pigeonhole Sort/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Array2DTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const A = Randomize.Array1D({ N: 7 });
const N = A.length;

// define tracer variables {
const tracer1 = new Array1DTracer('Array');
const tracer2 = new Array2DTracer('Holes');
const logTracer = new LogTracer('Console');
Layout.setRoot(new VerticalLayout([tracer1, tracer2, logTracer]));
tracer1.set(A);
Tracer.delay();
// }

let min = A[0];
let max = A[0];

for (let i = 1; i < N; i++) {
  if (A[i] < min) {
    min = A[i];
  }
  if (A[i] > max) {
    max = A[i];
  }
}
const range = max - min + 1;

const holes = new Array(range);
for (let i = 0; i < range; i++) {
  holes[i] = [];
}
// visualize {
tracer2.set(holes);
// }

// logger {
logTracer.println('Filling up holes');
// }
for (let i = 0; i < N; i++) {
  // visualize {
  tracer1.select(i);
  Tracer.delay();
  // }

  holes[A[i] - min].push(A[i]);

  // visualize {
  tracer2.set(holes);
  tracer1.deselect(i);
  // }
}

// logger {
logTracer.println('Building sorted array');
// }
let k = 0;
for (let i = 0; i < range; i++) {
  for (let j = 0; j < holes[i].length; j++) {
    // visualize {
    tracer2.select(i, j);
    Tracer.delay();
    // }
    A[k++] = holes[i][j];
    // visualize {
    tracer1.patch(k - 1, A[k - 1]);
    Tracer.delay();
    tracer2.deselect(i, j);
    tracer1.depatch(k - 1);
    // }
  }
}

// logger {
logTracer.println(`Sorted array is ${A}`);
// }

================
File: Divide and Conquer/Quicksort/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const chart = new ChartTracer();
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([chart, tracer, logger]));
const D = Randomize.Array1D({ N: 15 });
tracer.set(D);
tracer.chart(chart);
Tracer.delay();
// }

// logger {
logger.println(`original array = [${D.join(', ')}]`);
// }

function partition(D, low, high) {
  let i;
  let j;
  let s;
  while (high > low) {
    i = low;
    j = high;
    s = D[low];
    while (i < j) {
      // visualize {
      tracer.select(high);
      tracer.select(low);
      Tracer.delay();
      // }
      while (D[j] > s) {
        // visualize {
        tracer.select(j);
        Tracer.delay();
        tracer.deselect(j);
        // }
        j--;
      }
      D[i] = D[j];
      // visualize {
      tracer.patch(i, D[j]);
      Tracer.delay();
      tracer.depatch(i);
      // }
      while (s >= D[i] && i < j) {
        // visualize {
        tracer.select(i);
        Tracer.delay();
        tracer.deselect(i);
        // }
        i++;
      }
      D[j] = D[i];
      // visualize {
      tracer.patch(j, D[i]);
      Tracer.delay();
      tracer.depatch(j);
      tracer.deselect(high);
      tracer.deselect(low);
      // }
    }
    D[i] = s;
    // visualize {
    tracer.patch(i, s);
    Tracer.delay();
    tracer.depatch(i);
    // }
    partition(D, low, i - 1);
    low = i + 1;
  }
}

function quicksort(D) {
  partition(D, 0, D.length - 1);
}

quicksort(D);
// logger {
logger.println(`sorted array = [${D.join(', ')}]`);
// }

================
File: Divide and Conquer/Radix Sort/leastSignificantDigit.js
================
// import visualization libraries {
const { Tracer, Array2DTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const tracer = new Array2DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
const k = Randomize.Array1D({ N: 10, value: () => Randomize.Integer({ min: 1, max: 999 }) });
const D = [
  k,
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
];
tracer.set(D);
Tracer.delay();
// }

// logger {
logger.println(`original array = [${D[0].join(', ')}]`);
// }

function pow(base, expo) {
  let ans = 1;
  for (let i = 0; i < expo; i++) {
    ans *= base;
  }
  return ans;
}

function digit(i, exp) {
  return parseInt(D[0][i] / pow(10, exp) % 10);
}

for (let exp = 0; exp < 3; exp++) {
  // logger {
  logger.println(`Digit: ${exp}`);
  // }
  let i;
  for (i = 0; i < D[0].length; i++) {
    const d = digit(i, exp);
    // visualize {
    tracer.select(0, i);
    Tracer.delay();
    // }
    D[2][d] += 1;
    // visualize {
    tracer.patch(2, d, D[2][d]);
    Tracer.delay();
    tracer.depatch(2, d);
    tracer.deselect(0, i);
    // }
  }
  for (i = 1; i < 10; i++) {
    // visualize {
    tracer.select(2, i - 1);
    Tracer.delay();
    // }
    D[2][i] += D[2][i - 1];
    // visualize {
    tracer.patch(2, i, D[2][i]);
    Tracer.delay();
    tracer.depatch(2, i);
    tracer.deselect(2, i - 1);
    // }
  }
  for (i = D[0].length - 1; i >= 0; i--) {
    const d = digit(i, exp);
    // visualize {
    tracer.select(0, i);
    Tracer.delay();
    // }
    D[2][d] -= 1;
    // visualize {
    tracer.patch(2, d, D[2][d]);
    Tracer.delay();
    tracer.depatch(2, d);
    // }
    D[1][D[2][d]] = D[0][i];
    // visualize {
    tracer.patch(1, D[2][d], D[1][D[2][d]]);
    Tracer.delay();
    tracer.depatch(1, D[2][d]);
    tracer.deselect(0, i);
    // }
  }
  for (i = 0; i < D[0].length; i++) {
    // visualize {
    tracer.select(1, i);
    Tracer.delay();
    // }
    D[0][i] = D[1][i];
    // visualize {
    tracer.patch(0, i, D[0][i]);
    Tracer.delay();
    tracer.depatch(0, i);
    tracer.deselect(1, i);
    // }
  }
  for (i = 0; i < 10; i++) {
    D[2][i] = 0;
    // visualize {
    tracer.patch(2, i, D[2][i]);
    Tracer.delay();
    tracer.depatch(2, i);
    // }
  }
}
// logger {
logger.println(`sorted array = [${D[0].join(', ')}]`);
// }

================
File: Dynamic Programming/Bellman-Ford's Shortest Path/code.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const tracer = new GraphTracer().weighted();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.log(logger);
const G = Randomize.Graph({ N: 5, ratio: .5, value: () => Randomize.Integer({ min: -2, max: 5 }), weighted: true });
tracer.set(G);
Tracer.delay();
// }

function BELLMAN_FORD(src, dest) {
  const weights = new Array(G.length);
  let i;
  let j;

  for (i = 0; i < G.length; i++) {
    weights[i] = MAX_VALUE;
    // visualize {
    tracer.updateNode(i, weights[i]);
    // }
  }
  weights[src] = 0;
  // visualize {
  tracer.updateNode(src, 0);
  // }

  // logger {
  logger.println(`Initializing weights to: [${weights}]`);
  logger.println('');
  // }

  // begin BF algorithm execution
  let k = G.length;
  while (k--) {
    // logger {
    logger.println(`Iteration: ${G.length - k}`);
    logger.println('------------------------------------------------------------------');
    // }

    for (i = 0; i < G.length; i++) {
      for (j = 0; j < G.length; j++) {
        if (G[i][j]) { // proceed to relax Edges only if a particular weight !== 0 (0 represents no edge)
          if (weights[j] > (weights[i] + G[i][j])) {
            weights[j] = weights[i] + G[i][j];
            // logger {
            logger.println(`weights[${j}] = weights[${i}] + ${G[i][j]}`);
            // }
          }
          // visualize {
          tracer.visit(j, i, weights[j]);
          Tracer.delay();
          tracer.leave(j, i);
          Tracer.delay();
          // }
        }
      }
    }

    // logger {
    logger.println(`updated weights: [${weights.join(', ')}]`);
    logger.println('');
    // }
  }

  // check for cycle
  logger.println('checking for cycle');
  for (i = 0; i < G.length; i++) {
    for (j = 0; j < G.length; j++) {
      if (G[i][j]) {
        if (weights[j] > (weights[i] + G[i][j])) {
          // logger {
          logger.println(`A cycle was detected: weights[${j}] > weights[${i}] + ${G[i][j]}`);
          // }
          return (MAX_VALUE);
        }
      }
    }
  }

  // logger {
  logger.println(`No cycles detected. Final weights for the source ${src} are: [${weights}]`);
  // }

  return weights[dest];
}

const src = Randomize.Integer({ min: 0, max: G.length - 1 });
let dest;
let MAX_VALUE = 0x7fffffff;
let minWeight;

/*
 src = start node
 dest = start node (but will eventually at as the end node)
 */

do {
  dest = Randomize.Integer({ min: 0, max: G.length - 1 });
}
while (src === dest);

// logger {
logger.println(`finding the shortest path from ${src} to ${dest}`);
// }

minWeight = BELLMAN_FORD(src, dest);

// logger {
if (minWeight === MAX_VALUE) {
  logger.println(`there is no path from ${src} to ${dest}`);
} else {
  logger.println(`the shortest path from ${src} to ${dest} is ${minWeight}`);
}
// }

================
File: Dynamic Programming/Catalan Number/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const N = 10;
const A = new Array(N + 1);
for (let i = N; i >= 0; i--) {
  A[i] = 0;
}

// define tracer variables {
const tracer = new Array1DTracer(' Catalan Numbers ');
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.set(A);
Tracer.delay();
// }

A[0] = 1;
// visualize {
tracer.patch(0, A[0]);
Tracer.delay();
tracer.depatch(0);
// }
A[1] = 1;
// visualize {
tracer.patch(1, A[1]);
Tracer.delay();
tracer.depatch(1);
// }

for (let i = 2; i <= N; i++) {
  for (let j = 0; j < i; j++) {
    A[i] += A[j] * A[i - j - 1];
    // visualize {
    tracer.select(j);
    Tracer.delay();
    tracer.select(i - j - 1);
    Tracer.delay();
    tracer.patch(i, A[i]);
    Tracer.delay();
    tracer.deselect(j);
    tracer.deselect(i - j - 1);
    tracer.depatch(i);
    // }
  }
}

// visualize {
logger.println(` The ${N}th Catalan Number is ${A[N]}`);
tracer.select(N);
Tracer.delay();
// }

================
File: Dynamic Programming/Fibonacci Sequence/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const tracer = new Array1DTracer('Sequence');
Layout.setRoot(new VerticalLayout([tracer]));
const index = 15;
const D = [1, 1];
for (let i = 2; i < index; i++) {
  D.push(0);
}
tracer.set(D);
Tracer.delay();
// }

for (let i = 2; i < index; i++) {
  D[i] = D[i - 2] + D[i - 1];
  // visualize {
  tracer.select(i - 2, i - 1);
  Tracer.delay();
  tracer.patch(i, D[i]);
  Tracer.delay();
  tracer.depatch(i);
  tracer.deselect(i - 2, i - 1);
  // }
}

================
File: Dynamic Programming/Floyd-Warshall's Shortest Path/code.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const tracer = new GraphTracer().weighted();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.log(logger);
const G = Randomize.Graph({ N: 5, ratio: 1, weighted: true });
tracer.set(G);
Tracer.delay();
// }

function FloydWarshall() {
  // Finds the shortest path between all nodes
  const S = new Array(G.length);
  for (let i = 0; i < G.length; i++) S[i] = new Array(G.length);
  for (let i = 0; i < G.length; i++) {
    for (let j = 0; j < G.length; j++) {
      // Distance to self is always 0
      if (i === j) S[i][i] = 0;
      // Distance between connected nodes is their weight
      else if (G[i][j] > 0) {
        S[i][j] = G[i][j];
      }// Else we don't know the distance and we set it to infinity
      else S[i][j] = MAX_VALUE;
    }
  }
  // If there is a shorter path using k, use it instead
  for (let k = 0; k < G.length; k++) {
    for (let i = 0; i < G.length; i++) {
      if (k === i) continue;
      // visualize {
      tracer.visit(k, i);
      Tracer.delay();
      // }
      for (let j = 0; j < G.length; j++) {
        if (i === j || j === k) continue;
        // visualize {
        tracer.visit(j, k);
        Tracer.delay();
        // }
        if (S[i][j] > S[i][k] + S[k][j]) {
          // visualize {
          tracer.visit(j, i, S[i][j]);
          Tracer.delay();
          // }
          S[i][j] = S[i][k] + S[k][j];
          // visualize {
          tracer.leave(j, i, S[i][j]);
          // }
        }
        // visualize {
        tracer.leave(j, k);
        // }
      }
      // visualize {
      tracer.leave(k, i);
      Tracer.delay();
      // }
    }
  }
  // logger {
  for (let i = 0; i < G.length; i++) {
    for (let j = 0; j < G.length; j++) {
      if (S[i][j] === MAX_VALUE) logger.println(`there is no path from ${i} to ${j}`);
      else logger.println(`the shortest path from ${i} to ${j} is ${S[i][j]}`);
    }
  }
  // }
}

let MAX_VALUE = Infinity;
// logger {
logger.println('finding the shortest paths from and to all nodes');
// }
FloydWarshall();

================
File: Dynamic Programming/Integer Partition/code.js
================
// import visualization libraries {
const { Tracer, Array2DTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const tracer = new Array2DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
const integer = Randomize.Integer({ min: 5, max: 14 });
const D = [];
const A = "";
for (let i = 0; i <= integer; i++) {
  D.push([]);
  D[i][0] = 1
  for (let j = 1; j <= integer; j++) D[i][j] = 0;
}
tracer.set(D);
Tracer.delay();
// }

function partition(A, n, p) {
    // logger {
    if (p == 0) logger.println(`[${A.split('').join(', ')}]`);
    // }
    else {
        if (n > 1) partition(A, n - 1, p);
        if (n <= p) partition(n + A, n, p - n);
    }
}

function integerPartition(n) {

  // cycle through each cell of matrix
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= n; j++) {
      if (i > j)  {
        // visualize {
        tracer.select(i, j);
        Tracer.delay();
        // }
        // set cell to cell above it
        D[i][j] = D[i - 1][j];
        // visualize {
        tracer.patch(i, j, D[i][j]);
        Tracer.delay();
        tracer.depatch(i, j);
        tracer.deselect(i, j);
        // }
      }
      else {
        // visualize {
          tracer.select(i, j);
          Tracer.delay();
        // }
        // grab above cell and add it to previous cell
        const above = D[i - 1][j];
        const left = D[i][j - i];
        D[i][j] = above + left;
        // visualize {
          tracer.patch(i, j, D[i][j]);
          Tracer.delay();
          tracer.depatch(i, j);
          tracer.deselect(i, j);
        // }
      }
    }
  }
  return D[n][n];
}

// logger {
logger.println(`Partitioning: ${integer}`);
// }
partition(A, integer, integer);
const part = integerPartition(integer);
// logger {
logger.println(part);
// }

================
File: Dynamic Programming/Knapsack Problem/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Array2DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const val = [1, 4, 5, 7]; // The value of all available items
const wt = [1, 3, 4, 5]; // The weights of available items
const W = 7; // The maximum weight we can carry in our collection
const N = val.length;
const DP = new Array(N + 1);

for (let i = 0; i < N + 1; i++) {
  DP[i] = new Array(W + 1);
  for (let j = 0; j < W + 1; j++) {
    DP[i][j] = 0;
  }
}

// define tracer variables {
const tracer = new Array2DTracer('Knapsack Table');
const valuesTracer = new Array1DTracer('Values');
const weightsTracer = new Array1DTracer('Weights');
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, valuesTracer, weightsTracer, logger]));
tracer.set(DP);
valuesTracer.set(val);
weightsTracer.set(wt);
Tracer.delay();
// }

for (let i = 0; i <= N; i++) {
  for (let j = 0; j <= W; j++) {
    if (i === 0 || j === 0) {
      /*
      If we have no items or maximum weight we can take in collection is 0
      then the total weight in our collection is 0
      */
      DP[i][0] = 0;
      // visualize {
      tracer.patch(i, j, DP[i][j]);
      Tracer.delay();
      tracer.depatch(i, j);
      // }
    } else if (wt[i - 1] <= j) { // take the current item in our collection
      // visualize {
      weightsTracer.select(i - 1);
      valuesTracer.select(i - 1);
      Tracer.delay();
      tracer.select(i - 1, j - wt[i - 1]);
      tracer.select(i - 1, j);
      Tracer.delay();
      // }
      const A = val[i - 1] + DP[i - 1][j - wt[i - 1]];
      const B = DP[i - 1][j];
      /*
      find the maximum of these two values
      and take which gives us a greater weight
       */
      if (A > B) {
        DP[i][j] = A;
        // visualize {
        tracer.patch(i, j, DP[i][j]);
        Tracer.delay();
        // }
      } else {
        DP[i][j] = B;
        // visualize {
        tracer.patch(i, j, DP[i][j]);
        Tracer.delay();
        // }
      }
      // visualize {
      // opt subproblem depatch
      tracer.depatch(i, j);
      tracer.deselect(i - 1, j);
      tracer.deselect(i - 1, j - wt[i - 1]);
      valuesTracer.deselect(i - 1);
      weightsTracer.deselect(i - 1);
      // }
    } else { // leave the current item from our collection
      DP[i][j] = DP[i - 1][j];
      // visualize {
      tracer.patch(i, j, DP[i][j]);
      Tracer.delay();
      tracer.depatch(i, j);
      // }
    }
  }
}

// logger {
logger.println(` Best value we can achieve is ${DP[N][W]}`);
// }

================
File: Dynamic Programming/Knuth-Morris-Pratt's String Search/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Array2DTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }
const string = "AAAABAABAAAABAAABAAAA";
const pattern = "AAAABAAA";

let _next = Array(...Array(pattern.length)).map(Number.prototype.valueOf, 0);
// define tracer variables {
const pattern_tracer = new Array2DTracer('Pattern');
const string_tracer = new Array1DTracer('String');
Layout.setRoot(new VerticalLayout([pattern_tracer, string_tracer]));
pattern_tracer.set([_next, pattern, pattern]);
string_tracer.set(string); Tracer.delay();
// }

function get_next(pattern)
{
    let q = 1; // postfix pointer
    let k = 0; // prefix pointer
    // visualize {
    pattern_tracer.select(2, k);
    // }
    for (; q < pattern.length; ++q)
    {
        // visualize {
        pattern_tracer.select(1, q); Tracer.delay();
        // }
        while ((k > 0) && (pattern[q] !== pattern[k]))
        {
            // visualize {
            pattern_tracer.select(0, k - 1); Tracer.delay();
            pattern_tracer.deselect(2, k);
            pattern_tracer.select(2, _next[k - 1]); Tracer.delay();
            pattern_tracer.deselect(0, k - 1);
            // }
            k = _next[k - 1];
        }
        if (pattern[q] === pattern[k])
        {
            // visualize {
            pattern_tracer.deselect(2, k);
            pattern_tracer.select(2, k + 1); Tracer.delay();
            // }
            ++k;
        }
        // visualize {
        pattern_tracer.patch(0, q, k); Tracer.delay();
        pattern_tracer.depatch(0, q); Tracer.delay();
        pattern_tracer.deselect(1, q);
        // }
        _next[q] = k;
    }
    // visualize {
    pattern_tracer.deselect(2, k);
    pattern_tracer.set([_next, pattern]); Tracer.delay();
    // }
}

function KMP(string, pattern)
{
    const match_positions = [];
    let match_start_position;

    let i = 0; // string pointer
    let k = 0; // pattern pointer
    get_next(pattern);
    for (; i < string.length; i++)
    {
        // visualize {
        string_tracer.select(i);
        pattern_tracer.select(1, k); Tracer.delay();
        // }
        while ((k > 0) && (string[i] != pattern[k]))
        {
            // visualize {
            pattern_tracer.select(0, k - 1); Tracer.delay();
            pattern_tracer.deselect(1, k);
            pattern_tracer.select(1, _next[k - 1]); Tracer.delay();
            pattern_tracer.deselect(0, k - 1);
            // }
            k = _next[k - 1];
        }
        if (string[i] === pattern[k])
        {
            ++k;
            if (k === pattern.length)
            {
                match_start_position = i - pattern.length + 1;
                match_positions.push(match_start_position);
                // visualize {
                string_tracer.select(match_start_position, match_start_position + pattern.length - 1); Tracer.delay();
                string_tracer.deselect(match_start_position, match_start_position + pattern.length - 1); Tracer.delay();
                pattern_tracer.select(0, k - 1); Tracer.delay();
                pattern_tracer.deselect(1, k - 1);
                pattern_tracer.select(1, _next[k - 1]); Tracer.delay();
                pattern_tracer.deselect(0, k - 1);
                // }
                k = _next[k - 1];
            }
            else
            {
                // visualize {
                pattern_tracer.deselect(1, k - 1);
                pattern_tracer.select(1, k); Tracer.delay();
                // }
            }
        }
        else
        {
            // visualize {
            pattern_tracer.select(0, k); Tracer.delay();
            // }
        }
        // visualize {
        pattern_tracer.deselect(0, k);
        pattern_tracer.deselect(1, k);
        string_tracer.deselect(i);
        // }
    }
    // visualize {
    for (let j = 0; j < match_positions.length; j++)
    {
        string_tracer.select(match_positions[j], match_positions[j] + pattern.length - 1); Tracer.delay();
        string_tracer.deselect(match_positions[j], match_positions[j] + pattern.length - 1);
    }
    // }
}

KMP(string, pattern);

================
File: Dynamic Programming/Levenshtein's Edit Distance/code.js
================
// import visualization libraries {
const { Tracer, Array2DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const str1 = 'stack';
const str2 = 'racket';
const table = new Array(str1.length + 1);

for (let i = 0; i < str1.length + 1; i++) {
  table[i] = new Array(str2.length + 1).fill(-1);
  table[i][0] = i;
}
for (let i = 1; i < str2.length + 1; i++) {
  table[0][i] = i;
}

// define tracer variables {
const tracer = new Array2DTracer('Distance Table');
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.set(table);
Tracer.delay();
// }

// logger {
logger.println('Initialized DP Table');
logger.println(`Y-Axis (Top to Bottom): ${str1}`);
logger.println(`X-Axis (Left to Right): ${str2}`);
// }

const dist = (function editDistance(str1, str2, table) {
  // display grid with words
  // logger {
  logger.println(`*** ${str2.split('').join(' ')}`);
  table.forEach((item, index) => {
    const character = (index === 0) ? '*' : str1[index - 1];
    logger.println(`${character}\t${item}`);
  });
  // }

  // begin ED execution
  for (let i = 1; i < str1.length + 1; i++) {
    for (let j = 1; j < str2.length + 1; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        // visualize {
        tracer.select(i - 1, j - 1);
        Tracer.delay();
        // }
        table[i][j] = table[i - 1][j - 1];
        // visualize {
        tracer.patch(i, j, table[i][j]);
        Tracer.delay();
        tracer.depatch(i, j);
        tracer.deselect(i - 1, j - 1);
        // }
      } else {
        // visualize {
        tracer.select(i - 1, j);
        tracer.select(i, j - 1);
        tracer.select(i - 1, j - 1);
        Tracer.delay();
        // }
        table[i][j] = Math.min(table[i - 1][j], table[i][j - 1], table[i - 1][j - 1]) + 1;
        // visualize {
        tracer.patch(i, j, table[i][j]);
        Tracer.delay();
        tracer.depatch(i, j);
        tracer.deselect(i - 1, j);
        tracer.deselect(i, j - 1);
        tracer.deselect(i - 1, j - 1);
        // }
      }
    }
  }

  // visualize {
  tracer.select(str1.length, str2.length);
  // }
  return table[str1.length][str2.length];
}(str1, str2, table));

// logger {
logger.println(`Minimum Edit Distance: ${dist}`);
// }

================
File: Dynamic Programming/Longest Common Subsequence/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Array2DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const string1 = 'AGGTAB';
const string2 = 'GXTXAYB';
const m = string1.length;
const n = string2.length;
const A = new Array(m + 1);
for (let i = 0; i < m + 1; i++) {
  A[i] = new Array(n + 1);
}

// define tracer variables {
const tracer1 = new Array1DTracer('String 1');
const tracer2 = new Array1DTracer('String 2');
const tracer3 = new Array2DTracer('Memo Table');
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer1, tracer2, tracer3, logger]));
tracer1.set(string1);
tracer2.set(string2);
tracer3.set(A);
Tracer.delay();
// }

let i;
let j;

// Build the memo table in bottom up fashion
for (i = 0; i <= m; i++) {
  for (j = 0; j <= n; j++) {
    if (i === 0 || j === 0) {
      A[i][j] = 0;
    } else if (string1[i - 1] === string2[j - 1]) {
      // visualize {
      tracer1.select(i - 1);
      Tracer.delay();
      tracer2.select(j - 1);
      Tracer.delay();
      tracer3.select(i - 1, j - 1);
      Tracer.delay();
      // }

      A[i][j] = A[i - 1][j - 1] + 1;

      // visualize {
      tracer1.deselect(i - 1);
      tracer2.deselect(j - 1);
      tracer3.deselect(i - 1, j - 1);
      // }
    } else {
      // visualize {
      tracer3.select(i - 1, j);
      Tracer.delay();
      tracer3.select(i, j - 1);
      Tracer.delay();
      // }

      if (A[i - 1][j] > A[i][j - 1]) {
        A[i][j] = A[i - 1][j];
      } else {
        A[i][j] = A[i][j - 1];
      }

      // visualize {
      tracer3.deselect(i - 1, j);
      tracer3.deselect(i, j - 1);
      // }
    }
    // visualize {
    tracer3.patch(i, j, A[i][j]);
    Tracer.delay();
    tracer3.depatch(i, j);
    // }
  }
}

let finalString = '';
i = m;
j = n;
while (i >= 1 && j >= 1) {
  // visualize {
  tracer3.select(i, j);
  Tracer.delay();
  // }
  if (string1[i - 1] === string2[j - 1]) {
    // visualize {
    tracer1.select(i - 1);
    Tracer.delay();
    tracer2.select(j - 1);
    Tracer.delay();
    // }

    finalString = string1[i - 1] + finalString;
    i--;
    j--;
  } else if (A[i - 1][j] > A[i][j - 1]) {
    i--;
  } else {
    j--;
  }
}

// logger {
logger.println(`Longest Common Subsequence Length is ${A[m][n]}`);
logger.println(`Longest Common Subsequence is ${finalString}`);
// }

================
File: Dynamic Programming/Longest Increasing Subsequence/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
const A = Randomize.Array1D({ N: 10, value: () => Randomize.Integer({ min: 0, max: 10 }) });
const LIS = new Array(A.length);
tracer.set(A);
Tracer.delay();
// }

// Initialize LIS values for all indexes
for (let i = 0; i < A.length; i++) {
  LIS[i] = 1;
}

// logger {
logger.println('Calculating Longest Increasing Subsequence values in bottom up manner ');
// }
// Compute optimized LIS values in bottom up manner
for (let i = 1; i < A.length; i++) {
  // visualize {
  tracer.select(i);
  logger.println(` LIS[${i}] = ${LIS[i]}`);
  // }
  for (let j = 0; j < i; j++) {
    // visualize {
    tracer.patch(j);
    Tracer.delay();
    tracer.depatch(j);
    // }
    if (A[i] > A[j] && LIS[i] < LIS[j] + 1) {
      LIS[i] = LIS[j] + 1;
      // logger {
      logger.println(` LIS[${i}] = ${LIS[i]}`);
      // }
    }
  }
  // visualize {
  tracer.deselect(i);
  // }
}

// Pick maximum of all LIS values
// logger {
logger.println('Now calculate maximum of all LIS values ');
// }
let max = LIS[0];
for (let i = 1; i < A.length; i++) {
  if (max < LIS[i]) {
    max = LIS[i];
  }
}
// logger {
logger.println(`Longest Increasing Subsequence = max of all LIS = ${max}`);
// }

================
File: Dynamic Programming/Longest Palindromic Subsequence/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Array2DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const seq = 'BBABCBCAB';
let N;
N = seq.length;

const L = new Array(N);

let i;
let j;
for (i = 0; i < N; i++) {
  L[i] = new Array(N);
}
for (i = 0; i < N; i++) {
  L[i][i] = 1;
}

// define tracer variables {
const tracer = new Array1DTracer('Input Text');
const matrix = new Array2DTracer('Matrix');
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, matrix, logger]));
tracer.set(seq);
matrix.set(L);
Tracer.delay();
// }

function max(a, b) {
  if (a > b) {
    return a;
  }
  return b;
}

// logger {
logger.println('LPS for any string with length = 1 is 1');
// }
for (i = 2; i <= N; i++) {
  // logger {
  logger.println('--------------------------------------------------');
  logger.println(`Considering a sub-string of length ${i}`);
  logger.println('--------------------------------------------------');
  // }
  for (j = 0; j < N - i + 1; j++) {
    const k = j + i - 1;
    // visualize {
    tracer.select(j);
    Tracer.delay();
    tracer.patch(k);
    Tracer.delay();
    // }

    // logger {
    logger.println(`Comparing ${seq[j]} and ${seq[k]}`);
    // }

    if (seq[j] === seq[k] && i === 2) {
      // logger {
      logger.println(`They are equal and size of the string in the interval${j} to ${k} is 2, so the Longest Palindromic Subsequence in the Given range is 2`);
      // }

      // visualize {
      matrix.patch(j, k);
      Tracer.delay();
      // }

      L[j][k] = 2;
      // visualize {
      matrix.set(L);

      matrix.depatch(j, k);
      Tracer.delay();
      // }
    } else if (seq[j] === seq[k]) {
      // logger {
      logger.println(`They are equal, so the Longest Palindromic Subsequence in the Given range is 2 + the Longest Increasing Subsequence between the indices ${j + 1} to ${k - 1}`);
      // }

      // visualize {
      matrix.patch(j, k);
      Tracer.delay();
      matrix.select(j + 1, k - 1);
      Tracer.delay();
      // }

      L[j][k] = L[j + 1][k - 1] + 2;
      // visualize {
      matrix.set(L);

      matrix.depatch(j, k);
      Tracer.delay();
      matrix.deselect(j + 1, k - 1);
      Tracer.delay();
      // }
    } else {
      // logger {
      logger.println(`They are NOT equal, so the Longest Palindromic Subsequence in the Given range is the maximum Longest Increasing Subsequence between the indices ${j + 1} to ${k} and ${j} to ${k - 1}`);
      // }
      // visualize {
      matrix.patch(j, k);
      Tracer.delay();
      matrix.select(j + 1, k);
      Tracer.delay();
      matrix.select(j, k - 1);
      Tracer.delay();
      // }

      L[j][k] = max(L[j + 1][k], L[j][k - 1]);
      // visualize {
      matrix.set(L);

      matrix.depatch(j, k);
      Tracer.delay();
      matrix.deselect(j + 1, k);
      Tracer.delay();
      matrix.deselect(j, k - 1);
      Tracer.delay();
      // }
    }
    // logger {
    logger.println('--------------------------------------------------');
    // }
    // visualize {
    tracer.deselect(j);
    Tracer.delay();
    tracer.depatch(k);
    Tracer.delay();
    // }
  }
}
// logger {
logger.println(`Longest Increasing Subsequence of the given string = L[0][${N - 1}]=${L[0][N - 1]}`);
// }

================
File: Dynamic Programming/Maximum Subarray/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const D = [-2, -3, 4, -1, -2, 1, 5, -3];

// define tracer variables {
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.set(D);
Tracer.delay();
// }

const maxSubarraySum = (function maxSubarray(array) {
  let maxSoFar = 0;
  let maxEndingHere = 0;

  // logger {
  logger.println('Initializing maxSoFar = 0 & maxEndingHere = 0');
  // }

  for (let i = 0; i < array.length; i++) {
    // visualize {
    tracer.select(i);
    // }
    // logger {
    logger.println(`${maxEndingHere} + ${array[i]}`);
    // }
    maxEndingHere += array[i];
    // logger {
    logger.println(`=> ${maxEndingHere}`);
    // }

    if (maxEndingHere < 0) {
      // logger {
      logger.println('maxEndingHere is negative, set to 0');
      // }
      maxEndingHere = 0;
    }

    if (maxSoFar < maxEndingHere) {
      // logger {
      logger.println(`maxSoFar < maxEndingHere, setting maxSoFar to maxEndingHere (${maxEndingHere})`);
      // }
      maxSoFar = maxEndingHere;
    }

    // visualize {
    Tracer.delay();
    tracer.deselect(i);
    // }
  }

  return maxSoFar;
}(D));

// logger {
logger.println(`Maximum Subarray's Sum is: ${maxSubarraySum}`);
// }

================
File: Dynamic Programming/Maximum Sum Path/code.js
================
// import visualization libraries {
const { Tracer, Array2DTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const D = Randomize.Array2D({ N: 5, M: 5, value: () => Randomize.Integer({ min: 1, max: 5 }) });
const dataViewer = new Array2DTracer();
const tracer = new Array2DTracer('Results Table');
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([dataViewer, tracer, logger]));
dataViewer.set(D);
const DP = [];
for (let i = 0; i < D.length; i++) {
  DP.push([]);
  for (let j = 0; j < D[i].length; j++) {
    DP[i].push(Infinity);
  }
}
tracer.set(DP);
Tracer.delay();
// }

const N = DP.length;
const M = DP[0].length;

function update(i, j, value) {
  DP[i][j] = value;
  // visualize {
  dataViewer.select(i, j);
  Tracer.delay();
  tracer.patch(i, j, DP[i][j]);
  Tracer.delay();
  tracer.depatch(i, j);
  dataViewer.deselect(i, j);
  // }
}

for (let i = 0; i < N; i++) {
  for (let j = 0; j < M; j++) {
    if (i === 0 && j === 0) {
      update(i, j, D[i][j]);
    } else if (i === 0) {
      // visualize {
      tracer.select(i, j - 1);
      // }
      update(i, j, DP[i][j - 1] + D[i][j]);
      // visualize {
      tracer.deselect(i, j - 1);
      // }
    } else if (j === 0) {
      // visualize {
      tracer.select(i - 1, j);
      // }
      update(i, j, DP[i - 1][j] + D[i][j]);
      // visualize {
      tracer.deselect(i - 1, j);
      // }
    } else {
      // visualize {
      tracer.select(i, j - 1);
      tracer.select(i - 1, j);
      // }
      update(i, j, Math.max(DP[i][j - 1], DP[i - 1][j]) + D[i][j]);
      // visualize {
      tracer.deselect(i, j - 1);
      tracer.deselect(i - 1, j);
      // }
    }
  }
}
// logger {
logger.println(`max = ${DP[N - 1][M - 1]}`);
// }

================
File: Dynamic Programming/Nth Factorial/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const tracer = new Array1DTracer('Sequence');
Layout.setRoot(new VerticalLayout([tracer]));
const index = 15;
const D = [1];
for (let i = 1; i < index; i++) {
  D.push(0);
}
tracer.set(D);
Tracer.delay();
// }

for (let i = 1; i < index; i++) {
  D[i] = D[i - 1] * i;
  // visualize {
  tracer.select(i - 1);
  Tracer.delay();
  tracer.patch(i, D[i]);
  Tracer.delay();
  tracer.depatch(i);
  tracer.deselect(i - 1);
  // }
}

================
File: Dynamic Programming/Pascal's Triangle/code.js
================
// import visualization libraries {
const { Tracer, Array2DTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const N = 9;
const A = new Array(N);
for (let i = N - 1; i >= 0; i--) {
  A[i] = new Array(N);
}

// define tracer variables {
const tracer = new Array2DTracer('Pascal\'s Triangle');
Layout.setRoot(new VerticalLayout([tracer]));
tracer.set(A);
Tracer.delay();
// }

for (let i = 0; i < N; i++) {
  for (let j = 0; j <= i; j++) {
    if (j === i || j === 0) { // First and last values in every row are 1
      A[i][j] = 1;

      // visualize {
      tracer.patch(i, j, A[i][j]);
      Tracer.delay();
      tracer.depatch(i, j);
      // }
    } else { // Other values are sum of values just above and left of above
      // visualize {
      tracer.select(i - 1, j - 1);
      Tracer.delay();
      tracer.select(i - 1, j);
      Tracer.delay();
      // }

      A[i][j] = A[i - 1][j - 1] + A[i - 1][j];

      // visualize {
      tracer.patch(i, j, A[i][j]);
      Tracer.delay();
      tracer.depatch(i, j);
      tracer.deselect(i - 1, j - 1);
      tracer.deselect(i - 1, j);
      // }
    }
  }
}

================
File: Dynamic Programming/Shortest Common Supersequence/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Array2DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const string1 = 'AGGTAB';
const string2 = 'GXTXAYB';
const m = string1.length;
const n = string2.length;
const A = new Array(m + 1);
for (let i = 0; i < m + 1; i++) {
  A[i] = new Array(n + 1);
}

// define tracer variables {
const tracer1 = new Array1DTracer('String 1');
const tracer2 = new Array1DTracer('String 2');
const tracer3 = new Array2DTracer('Memo Table');
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer1, tracer2, tracer3, logger]));
tracer1.set(string1);
tracer2.set(string2);
tracer3.set(A);
Tracer.delay();
// }

let i;
let j;

// Fill memo table in bottom up manner
for (i = 0; i <= m; i++) {
  for (j = 0; j <= n; j++) {
    if (i === 0) {
      A[i][j] = j;
    } else if (j === 0) {
      A[i][j] = i;
    } else if (string1[i - 1] === string2[j - 1]) {
      // visualize {
      tracer1.select(i - 1);
      Tracer.delay();
      tracer2.select(j - 1);
      Tracer.delay();
      tracer3.select(i - 1, j - 1);
      Tracer.delay();
      // }

      A[i][j] = A[i - 1][j - 1] + 1;

      // visualize {
      tracer1.deselect(i - 1);
      tracer2.deselect(j - 1);
      tracer3.deselect(i - 1, j - 1);
      // }
    } else {
      // visualize {
      tracer3.select(i - 1, j);
      Tracer.delay();
      tracer3.select(i, j - 1);
      Tracer.delay();
      // }

      if (A[i - 1][j] < A[i][j - 1]) {
        A[i][j] = 1 + A[i - 1][j];
      } else {
        A[i][j] = 1 + A[i][j - 1];
      }

      // visualize {
      tracer3.deselect(i - 1, j);
      tracer3.deselect(i, j - 1);
      // }
    }
    // visualize {
    tracer3.patch(i, j, A[i][j]);
    Tracer.delay();
    tracer3.depatch(i, j);
    // }
  }
}

// logger {
logger.println(`Shortest Common Supersequence is ${A[m][n]}`);
// }

================
File: Dynamic Programming/Sieve of Eratosthenes/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const N = 30;
const a = [];
const b = [];
for (let i = 1; i <= N; i++) {
  a.push(i);
  b.push(0);
}

// define tracer variables {
const tracer = new Array1DTracer('Sieve');
tracer.set(a);
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
Tracer.delay();
// }

// visualize {
logger.println('1 is not prime');
tracer.select(0);
Tracer.delay();
// }
for (let i = 2; i <= N; i++) {
  if (b[i] === 0) {
    // visualize {
    logger.println(`${i} is not marked, so it is prime`);
    // a[i-1] is prime mark by red indicators
    tracer.patch(i - 1);
    Tracer.delay();
    // }
    for (let j = i + i; j <= N; j += i) {
      b[j] = 1; // a[j-1] is not prime, mark by blue indicators
      // visualize {
      logger.println(`${j} is a multiple of ${i} so it is marked as composite`);
      tracer.select(j - 1);
      Tracer.delay();
      // }
    }
    // visualize {
    tracer.depatch(i - 1);
    // }
  }
}
// logger {
logger.println(`The unmarked numbers are the prime numbers from 1 to ${N}`);
// }

================
File: Dynamic Programming/Sliding Window/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const tracer = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
const D = Randomize.Array1D({ N: 20, value: () => Randomize.Integer({ min: -5, max: 5 }) });
tracer.set(D);
Tracer.delay();
// }

let sum = D[0] + D[1] + D[2];
let max = sum;
// visualize {
tracer.select(0, 2);
logger.println(`sum = ${sum}`);
Tracer.delay();
// }
for (let i = 3; i < D.length; i++) {
  sum += D[i] - D[i - 3];
  if (max < sum) max = sum;
  // visualize {
  tracer.deselect(i - 3);
  tracer.select(i);
  logger.println(`sum = ${sum}`);
  Tracer.delay();
  // }
}
// visualize {
tracer.deselect(D.length - 3, D.length - 1);
logger.println(`max = ${max}`);
// }

================
File: Dynamic Programming/Ugly Numbers/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const N = 15;
const A = new Array(N);
for (let i = N - 1; i >= 0; i--) {
  A[i] = 0;
}
A[0] = 1; // By convention 1 is an ugly number

const M = [2, 3, 5]; // multiples of 2, 3, 5 respectively
const I = [0, 0, 0]; // iterators of 2, 3, 5 respectively

// define tracer variables {
const tracer = new Array1DTracer('Ugly Numbers');
const tracer2 = new Array1DTracer('Multiples of 2, 3, 5');
const tracer3 = new Array1DTracer(' Iterators I0, I1, I2 ');
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, tracer2, tracer3, logger]));
tracer.set(A);
tracer2.set(M);
tracer3.set(I);
Tracer.delay();
// }

for (let i = 1; i < N; i++) {
  // next is minimum of m2, m3 and m5
  const next = (M[0] <= M[1]) ? (M[0] <= M[2]) ? M[0] : M[2] : (M[1] <= M[2]) ? M[1] : M[2];
  // logger {
  logger.println(` Minimum of ${M[0]}, ${M[1]}, ${M[2]} : ${next}`);
  // }
  A[i] = next;

  // visualize {
  tracer.patch(i, A[i]);
  Tracer.delay();
  tracer.depatch(i);
  // }

  if (next === M[0]) {
    I[0]++;
    M[0] = A[I[0]] * 2;
    // visualize {
    tracer2.patch(0, M[0]);
    Tracer.delay();
    tracer3.patch(0, I[0]);
    Tracer.delay();
    tracer2.depatch(0);
    tracer3.depatch(0);
    // }
  }
  if (next === M[1]) {
    I[1]++;
    M[1] = A[I[1]] * 3;
    // visualize {
    tracer2.patch(1, M[1]);
    Tracer.delay();
    tracer3.patch(1, I[1]);
    Tracer.delay();
    tracer2.depatch(1);
    tracer3.depatch(1);
    // }
  }
  if (next === M[2]) {
    I[2]++;
    M[2] = A[I[2]] * 5;
    // visualize {
    tracer2.patch(2, M[2]);
    Tracer.delay();
    tracer3.patch(2, I[2]);
    Tracer.delay();
    tracer2.depatch(2);
    tracer3.depatch(2);
    // }
  }
}

================
File: Dynamic Programming/Z String Search/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// let pattern = "aab";
// let text = "aabxaabxcaabxaabxay";
const pattern = 'abc';
const text = 'xabcabzabc';

const len = pattern.length + text.length + 1;

const z = new Array(len);
z[0] = 0;

// define tracer variables {
const textTracer = new Array1DTracer('text');
const pattTracer = new Array1DTracer('pattern');
const concatTracer = new Array1DTracer('concatenated string');
const tracer = new Array1DTracer('zArray');
pattTracer.set(pattern);
textTracer.set(text);
tracer.set(z);
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([textTracer, pattTracer, concatTracer, tracer, logger]));
Tracer.delay();
// }

function createZarr(concat) {
  let left;
  let right;
  let N;
  N = concat.length;
  left = 0;
  right = 0;
  for (let i = 1; i < N; i++) {
    // visualize {
    tracer.select(i);
    Tracer.delay();
    // }
    if (i > right) {
      left = right = i;
      while (right < N && concat[right] === concat[right - left]) {
        // visualize {
        concatTracer.patch(right);
        concatTracer.select(right - left);
        logger.println(`${concat[right]} (at index ${right}) is equal to ${concat[right - left]} (at index ${right - left})`);
        Tracer.delay();
        concatTracer.depatch(right);
        concatTracer.deselect(right - left);
        // }
        right++;
      }
      // visualize {
      if (right < N) {
        concatTracer.patch(right);
        concatTracer.select(right - left);
        logger.println(`${concat[right]} (at index ${right}) is NOT equal to ${concat[right - left]} (at index ${right - left})`);
        Tracer.delay();
        concatTracer.depatch(right);
        concatTracer.deselect(right - left);
      }
      // }
      z[i] = (right - left);
      // logger {
      logger.println('--------------------------------');
      logger.println(`Value of z[${i}] = the length of the substring starting from ${i} which is also the prefix of the concatinated string(=${right - left})`);
      logger.println('--------------------------------');
      // }
      right--;
    } else if (z[i - left] < (right - i + 1)) {
      // visualize {
      logger.println(`The substring from index ${i - left} will not cross the right end.`);
      concatTracer.patch(right - i + 1);
      concatTracer.select(i - left);
      Tracer.delay();
      // }
      z[i] = z[i - left];
      // visualize {
      concatTracer.depatch(right - i + 1);
      concatTracer.deselect(i - left);
      // }
    } else {
      // logger {
      logger.println(`The substring from index ${i - left} will cross the right end.`);
      // }
      left = i;
      while (right < N && concat[right] === concat[right - left]) {
        // visualize {
        concatTracer.patch(right);
        concatTracer.select(right - left);
        logger.println(`${concat[right]} (at index ${right}) is equal to ${concat[right - left]} (at index ${right - left})`);
        Tracer.delay();
        concatTracer.depatch(right);
        concatTracer.deselect(right - left);
        // }
        right++;
      }
      // visualize {
      if (right < N) {
        concatTracer.patch(right);
        concatTracer.select(right - left);
        logger.println(`${concat[right]} (at index ${right}) is NOT equal to ${concat[right - left]} (at index ${right - left})`);
        Tracer.delay();
        concatTracer.depatch(right);
        concatTracer.deselect(right - left);
      }
      // }
      z[i] = (right - left);
      right--;
      // logger {
      logger.println('--------------------------------');
      logger.println(`Value of z[${i}] = the length of the substring starting from ${i} which is also the prefix of the concatinated string(=${right - left})`);
      logger.println('--------------------------------');
      // }
    }
    // visualize {
    tracer.deselect(i);
    tracer.set(z);
    // }
  }
}

const concat = `${pattern}$${text}`;
// visualize {
concatTracer.set(concat);
// }
const patLen = pattern.length;
createZarr(concat);
// visualize {
tracer.set(z);
// }
// logger {
logger.println('The Values in Z array equal to the length of the pattern indicates the index at which the pattern is present');
logger.println('===================================');
for (let i = 0; i < len; i++) {
  if (z[i] === patLen) {
    const pos = i - (patLen + 1);
    logger.println(`Pattern Found at index ${pos}`);
  }
}
logger.println('===================================');
// }

================
File: Greedy/Boyerâ€“Moore's Majority Vote/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const A = [1, 3, 3, 2, 1, 1, 1];
const N = A.length;

// define tracer variables {
const tracer = new Array1DTracer('List of element');
const logger = new LogTracer('Console');
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.set(A);
Tracer.delay();
// }

function isMajorityElement(element) {
  let count = 0;
  // logger {
  logger.println(`Verify majority element ${element}`);
  // }
  for (let i = N - 1; i >= 0; i--) {
    // visualize {
    tracer.patch(i, A[i]);
    Tracer.delay();
    // }
    if (A[i] === element) {
      count++;
    } else {
      // visualize {
      tracer.depatch(i);
      // }
    }
  }
  // logger {
  logger.println(`Count of our assumed majority element ${count}`);
  // }
  if (count > Math.floor(N / 2)) {
    // logger {
    logger.println('Our assumption was correct!');
    // }
    return true;
  }
  // logger {
  logger.println('Our assumption was incorrect!');
  // }
  return false;
}

function findProbableElement() {
  let index = 0;
  let count = 1;
  // visualize {
  tracer.select(index);
  Tracer.delay();
  // }
  // logger {
  logger.println(`Beginning with assumed majority element : ${A[index]} count : ${count}`);
  logger.println('--------------------------------------------------------');
  // }
  for (let i = 1; i < N; i++) {
    // visualize {
    tracer.patch(i, A[i]);
    Tracer.delay();
    // }
    if (A[index] === A[i]) {
      count++;
      // logger {
      logger.println(`Same as assumed majority element! Count : ${count}`);
      // }
    } else {
      count--;
      // logger {
      logger.println(`Not same as assumed majority element! Count : ${count}`);
      // }
    }

    if (count === 0) {
      // logger {
      logger.println('Wrong assumption in majority element');
      // }
      // visualize {
      tracer.deselect(index);
      tracer.depatch(i);
      // }
      index = i;
      count = 1;
      // visualize {
      tracer.select(i);
      Tracer.delay();
      // }
      // logger {
      logger.println(`New assumed majority element!${A[i]} Count : ${count}`);
      logger.println('--------------------------------------------------------');
      // }
    } else {
      // visualize {
      tracer.depatch(i);
      // }
    }
  }
  // logger {
  logger.println(`Finally assumed majority element ${A[index]}`);
  logger.println('--------------------------------------------------------');
  // }
  return A[index];
}

function findMajorityElement() {
  const element = findProbableElement();
  // logger {
  if (isMajorityElement(element) === true) {
    logger.println(`Majority element is ${element}`);
  } else {
    logger.println('No majority element');
  }
  // }
}

findMajorityElement();

================
File: Greedy/Dijkstra's Shortest Path/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const G = Randomize.Graph({ N: 5, ratio: 1, directed: false, weighted: true });
const MAX_VALUE = Infinity;
const S = []; // S[end] returns the distance from start node to end node
for (let i = 0; i < G.length; i++) S[i] = MAX_VALUE;

// define tracer variables {
const tracer = new GraphTracer().directed(false).weighted();
const tracerS = new Array1DTracer();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, tracerS, logger]));
tracer.log(logger);
tracer.set(G);
tracerS.set(S);
Tracer.delay();
// }

function Dijkstra(start, end) {
  let minIndex;
  let minDistance;
  const D = []; // D[i] indicates whether the i-th node is discovered or not
  for (let i = 0; i < G.length; i++) D.push(false);
  S[start] = 0; // Starting node is at distance 0 from itself
  // visualize {
  tracerS.patch(start, S[start]);
  Tracer.delay();
  tracerS.depatch(start);
  tracerS.select(start);
  // }
  let k = G.length;
  while (k--) {
    // Finding a node with the shortest distance from S[minIndex]
    minDistance = MAX_VALUE;
    for (let i = 0; i < G.length; i++) {
      if (S[i] < minDistance && !D[i]) {
        minDistance = S[i];
        minIndex = i;
      }
    }
    if (minDistance === MAX_VALUE) break; // If there is no edge from current node, jump out of loop
    D[minIndex] = true;
    // visualize {
    tracerS.select(minIndex);
    tracer.visit(minIndex);
    Tracer.delay();
    // }
    // For every unvisited neighbour of current node, we check
    // whether the path to it is shorter if going over the current node
    for (let i = 0; i < G.length; i++) {
      if (G[minIndex][i] && S[i] > S[minIndex] + G[minIndex][i]) {
        S[i] = S[minIndex] + G[minIndex][i];
        // visualize {
        tracerS.patch(i, S[i]);
        tracer.visit(i, minIndex, S[i]);
        Tracer.delay();
        tracerS.depatch(i);
        tracer.leave(i, minIndex);
        Tracer.delay();
        // }
      }
    }
    // visualize {
    tracer.leave(minIndex);
    Tracer.delay();
    // }
  }
  // logger {
  if (S[end] === MAX_VALUE) {
    logger.println(`there is no path from ${start} to ${end}`);
  } else {
    logger.println(`the shortest path from ${start} to ${end} is ${S[end]}`);
  }
  // }
}

const s = Randomize.Integer({ min: 0, max: G.length - 1 }); // s = start node
let e; // e = end node
do {
  e = Randomize.Integer({ min: 0, max: G.length - 1 });
} while (s === e);
// logger {
logger.println(`finding the shortest path from ${s} to ${e}`);
Tracer.delay();
// }
Dijkstra(s, e);

================
File: Greedy/Job Scheduling Problem/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const jobId = ['a', 'b', 'c', 'd', 'e'];
const deadline = [2, 1, 2, 1, 3];
const profit = [100, 19, 27, 25, 15];
const N = deadline.length;
// sort according to decreasing order of profit
// Bubble sort implemented ... Implement a better algorithm for better performance
for (let i = 0; i < N - 1; i++) {
  for (let j = 0; j < N - i - 1; j++) {
    if (profit[j] < profit[j + 1]) {
      let temp = profit[j];
      profit[j] = profit[j + 1];
      profit[j + 1] = temp;
      temp = deadline[j];
      deadline[j] = deadline[j + 1];
      deadline[j + 1] = temp;
      const t = jobId[j];
      jobId[j] = jobId[j + 1];
      jobId[j + 1] = t;
    }
  }
}

const slot = new Array(N);
const result = new Array(N);
for (let i = N - 1; i >= 0; i--) {
  result[i] = '-';
}

// define tracer variables {
const tracer3 = new Array1DTracer('Schedule');
const tracer = new Array1DTracer('Job Ids');
const tracer1 = new Array1DTracer('Deadlines');
const tracer2 = new Array1DTracer('Profit');
Layout.setRoot(new VerticalLayout([tracer3, tracer, tracer1, tracer2]));
tracer.set(jobId);
tracer1.set(deadline);
tracer2.set(profit);
tracer3.set(result);
Tracer.delay();
// }

// Initialise all slots to free
for (let i = 0; i < N; i++) {
  slot[i] = 0;
}

// Iterate through all the given jobs
for (let i = 0; i < N; i++) {
  /*
     Start from the last possible slot.
     Find a slot for the job
     */
  // visualize {
  tracer.select(i);
  Tracer.delay();
  tracer1.select(i);
  Tracer.delay();
  // }
  for (let j = Math.min(N, deadline[i]) - 1; j >= 0; j--) {
    if (slot[j] === 0) {
      // visualize {
      tracer3.patch(j, jobId[i]);
      Tracer.delay();
      // }
      result[j] = jobId[i];
      slot[j] = 1;
      // visualize {
      tracer3.depatch(j);
      // }
      break;
    }
  }
  // visualize {
  tracer.deselect(i);
  tracer1.deselect(i);
  // }
}

================
File: Greedy/Kruskal's Minimum Spanning Tree/code.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const tracer = new GraphTracer().directed(false).weighted();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
/* let G = [ // G[i][j] indicates the weight of the path from the i-th node to the j-th node
 [0, 3, 0, 1, 0],
 [5, 0, 1, 2, 4],
 [1, 0, 0, 2, 0],
 [0, 2, 0, 0, 1],
 [0, 1, 3, 0, 0]
 ]; */
const G = Randomize.Graph({ N: 5, ratio: 1, directed: false, weighted: true });
tracer.set(G);
Tracer.delay();
// }

function kruskal() {
  const vcount = G.length;

  // Preprocess: sort edges by weight.
  const edges = [];
  for (let vi = 0; vi < vcount - 1; vi++) {
    for (let vj = vi + 1; vj < vcount; vj++) {
      edges.push({
        0: vi,
        1: vj,
        weight: G[vi][vj],
      });
    }
  }
  edges.sort((ei, ej) => ei.weight - ej.weight);

  // Give each vertex a tree to decide if they are already in the same tree.
  const t = [];
  for (let i = 0; i < vcount; i++) {
    t[i] = {};
    t[i][i] = true;
  }

  let wsum = 0;
  for (let n = 0; n < vcount - 1 && edges.length > 0;) {
    const e = edges.shift(); // Get the edge of min weight
    // visualize {
    tracer.visit(e[0], e[1]);
    Tracer.delay();
    // }
    if (t[e[0]] === t[e[1]]) {
      // e[0] & e[1] already in the same tree, ignore
      // visualize {
      tracer.leave(e[0], e[1]);
      Tracer.delay();
      // }
      continue;
    }

    // Choose the current edge.
    wsum += e.weight;

    // Merge tree of e[0] & e[1]
    const tmerged = {};
    for (const i in t[e[0]]) tmerged[i] = true;
    for (const i in t[e[1]]) tmerged[i] = true;
    for (const i in tmerged) t[i] = tmerged;

    n += 1;
  }

  // logger {
  logger.println(`The sum of all edges is: ${wsum}`);
  // }
}

kruskal();

================
File: Greedy/Prim's Minimum Spanning Tree/code.js
================
// import visualization libraries {
const { Tracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
const tracer = new GraphTracer().directed(false).weighted();
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
tracer.log(logger);
/* let G = [ // G[i][j] indicates the weight of the path from the i-th node to the j-th node
 [0, 3, 0, 1, 0],
 [5, 0, 1, 2, 4],
 [1, 0, 0, 2, 0],
 [0, 2, 0, 0, 1],
 [0, 1, 3, 0, 0]
 ]; */
const G = Randomize.Graph({ N: 10, ratio: .4, directed: false, weighted: true });
tracer.set(G);
Tracer.delay();
// }

function prim() {
  // Finds a tree so that there exists a path between
  // every two nodes while keeping the cost minimal
  let minD;

  let minI;
  let minJ;
  let sum = 0;
  const D = [];
  for (let i = 0; i < G.length; i++) D.push(0);
  D[0] = 1; // First node is visited
  for (let k = 0; k < G.length - 1; k++) { // Searching for k edges
    minD = Infinity;
    for (let i = 0; i < G.length; i++) {
      if (D[i]) // First node in an edge must be visited
      {
        for (let j = 0; j < G.length; j++) {
          if (!D[j] && G[i][j]) {
            // visualize {
            tracer.visit(i, j);
            Tracer.delay();
            // }
            // Second node must not be visited and must be connected to first node
            if (G[i][j] < minD) {
              // Searching for cheapest edge which satisfies requirements
              minD = G[i][j];
              minI = i;
              minJ = j;
            }
            // visualize {
            tracer.leave(i, j);
            Tracer.delay();
            // }
          }
        }
      }
    }
    // visualize {
    tracer.visit(minI, minJ);
    Tracer.delay();
    // }
    D[minJ] = 1; // Visit second node and insert it into or tree
    sum += G[minI][minJ];
  }
  // logger {
  logger.println(`The sum of all edges is: ${sum}`);
  // }
}

// logger {
logger.println('nodes that belong to minimum spanning tree are: ');
// }
prim();

================
File: Greedy/Stable Matching/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const ARank = {
  Flavio: ['Valentine', 'July', 'Summer', 'Violet'],
  Stephen: ['Summer', 'July', 'Valentine', 'Violet'],
  Albert: ['July', 'Violet', 'Valentine', 'Summer'],
  Jack: ['July', 'Violet', 'Valentine', 'Summer'],
};

const BRank = {
  July: ['Jack', 'Stephen', 'Albert', 'Flavio'],
  Valentine: ['Flavio', 'Jack', 'Stephen', 'Albert'],
  Violet: ['Jack', 'Stephen', 'Flavio', 'Albert'],
  Summer: ['Stephen', 'Flavio', 'Albert', 'Jack'],
};

// define tracer variables {
const tracerA = new Array1DTracer('A');
const tracerB = new Array1DTracer('B');

const _aKeys = Object.keys(ARank);
const _bKeys = Object.keys(BRank);
tracerA.set(_aKeys);
tracerB.set(_bKeys);

const logTracer = new LogTracer('Console');
Layout.setRoot(new VerticalLayout([tracerA, tracerB, logTracer]));
Tracer.delay();
// }

function init(rank) {
  const o = {};
  for (const k in rank) {
    o[k] = {
      key: k,
      stable: false,
      rankKeys: rank[k],
    };
  }
  return o;
}

function extractUnstable(Q) {
  for (const k in Q) {
    if (Q[k].stable === false) {
      return Q[k];
    }
  }
}

const A = init(ARank);
const B = init(BRank);
let a;

while ((a = extractUnstable(A))) {
  // logger {
  logTracer.println(`Selecting ${a.key}`);
  Tracer.delay();
  // }

  const bKey = a.rankKeys.shift();
  const b = B[bKey];

  // logger {
  logTracer.println(`--> Choicing ${b.key}`);
  Tracer.delay();
  // }

  if (b.stable === false) {
    // logger {
    logTracer.println(`--> ${b.key} is not stable, stabilizing with ${a.key}`);
    Tracer.delay();
    // }

    a.stable = b;
    b.stable = a;

    // visualize {
    tracerA.select(_aKeys.indexOf(a.key));
    Tracer.delay();
    tracerB.select(_bKeys.indexOf(b.key));
    Tracer.delay();
    // }
  } else {
    const rankAinB = b.rankKeys.indexOf(a.key);
    const rankPrevAinB = b.rankKeys.indexOf(b.stable.key);
    if (rankAinB < rankPrevAinB) {
      // logger {
      logTracer.println(`--> ${bKey} is more stable with ${a.key} rather than ${b.stable.key} - stabilizing again`);
      Tracer.delay();
      // }

      A[b.stable.key].stable = false;
      // visualize {
      tracerA.deselect(_aKeys.indexOf(b.stable.key));
      Tracer.delay();
      // }

      a.stable = b;
      b.stable = a;

      // visualize {
      tracerA.select(_aKeys.indexOf(a.key));
      Tracer.delay();
      tracerB.select(_bKeys.indexOf(b.key));
      Tracer.delay();
      // }
    }
  }
}

================
File: Simple Recursive/Cellular Automata/code.js
================
// import visualization libraries {
const { Tracer, Array2DTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const gridSize = 10;
const generations = 4;
const fillChance = 0.55;

const G = [];
const nextG = [];
for (let i = 0; i < gridSize; i++) {
  G[i] = [];
  nextG[i] = [];
  for (let j = 0; j < gridSize; j++) {
    if (Math.random() < fillChance || i === 0 || j === 0 || i === gridSize - 1 || j === gridSize - 1) {
      G[i][j] = '#';
    } else {
      G[i][j] = '.';
    }
    nextG[i][j] = '#';
  }
}

// define tracer variables {
const tracer = new Array2DTracer();
Layout.setRoot(new VerticalLayout([tracer]));
tracer.set(G);
Tracer.delay();
// }

// visualize {
for (let gi = 0; gi < G.length; gi++) {
  for (let gj = 0; gj < G[gi].length; gj++) {
    if (G[gi][gj] === '#') {
      tracer.patch(gi, gj, G[gi][gj]);
    }
  }
}
// }

function CellularAutomata(fillShape, emptyShape) {
  const nextGrid = [];

  for (let i = 0; i < G.length; i++) {
    nextGrid[i] = [];
    for (let j = 0; j < G[i].length; j++) {
      let adjCount = 0;
      let twoAwayCount = 0;
      // look at the states of the neighboring cells
      for (let x = -2; x <= 2; x++) {
        for (let y = -2; y <= 2; y++) {
          if ((i + x >= 0 && i + x < G.length) && (j + y >= 0 && j + y < G[i].length)) {
            if (!(x !== 0 && y !== 0) && G[i + x][j + y] === emptyShape) {
              if (x === -2 || x === 2 || y === -2 || y === 2) {
                twoAwayCount++;
              } else {
                adjCount++;
              }
            }
          }
        }
      }
      // change the current cell's state according to these rules
      if ((adjCount >= 5)) {
        nextGrid[i][j] = fillShape;
      } else if (adjCount <= 1) {
        if (twoAwayCount < 3) {
          nextGrid[i][j] = fillShape;
        } else {
          nextGrid[i][j] = emptyShape;
        }
      } else {
        nextGrid[i][j] = emptyShape;
      }
    }
  }

  for (let i = 0; i < nextGrid.length; i++) {
    for (let j = 0; j < nextGrid[i].length; j++) {
      // visualize {
      tracer.depatch(i, j, G[i][j]);
      tracer.select(i, j);
      Tracer.delay();
      // }
      G[i][j] = nextGrid[i][j];
      // visualize {
      if (G[i][j] === fillShape) {
        tracer.patch(i, j, G[i][j]);
      } else {
        tracer.patch(i, j, G[i][j]);
        tracer.depatch(i, j, G[i][j]);
        tracer.deselect(i, j);
      }
      // }
    }
  }
}

for (let iter = 0; iter < generations; iter++) {
  CellularAutomata('#', '.');
}

================
File: Simple Recursive/Cycle Detection/code.js
================
// import visualization libraries {
const { Array2DTracer, Layout, LogTracer, GraphTracer, Tracer, VerticalLayout } = require('algorithm-visualizer');
// }


// define tracer variables {
function ListNode(val) {
    this.val = val
    this.next = null
}

const node0 = new ListNode(0)
const node1 = new ListNode(1)
const node2 = new ListNode(2)
const node3 = new ListNode(3)
const node4 = new ListNode(4)
const node5 = new ListNode(5)
const node6 = new ListNode(6)

const list = node0
list.next = node1
list.next.next = node2
list.next.next.next = node3
list.next.next.next.next = node4
list.next.next.next.next.next = node5
list.next.next.next.next.next.next = node6
list.next.next.next.next.next.next.next = node2

const graphTracer = new GraphTracer("Linked List").directed()
const logTracer = new LogTracer("Console")
Layout.setRoot(new VerticalLayout([graphTracer, logTracer]))

graphTracer.addNode(node0.val)
graphTracer.addNode(node1.val)
graphTracer.addNode(node2.val)
graphTracer.addNode(node3.val)
graphTracer.addNode(node4.val)
graphTracer.addNode(node5.val)
graphTracer.addNode(node6.val)
graphTracer.addEdge(node0.val, node1.val)
graphTracer.addEdge(node1.val, node2.val)
graphTracer.addEdge(node2.val, node3.val)
graphTracer.addEdge(node3.val, node4.val)
graphTracer.addEdge(node4.val, node5.val)
graphTracer.addEdge(node5.val, node6.val)
graphTracer.addEdge(node6.val, node2.val)
Tracer.delay()
// }

var listHasCycle = function(head) {
    // visualize {
    graphTracer.select(head.val)
    graphTracer.visit(head.val)
    Tracer.delay()
    graphTracer.deselect(head.val)
    graphTracer.leave(head.val)
    // }
    
    // 1. is there a cycle?
    let slow = head.next
    let fast = head.next.next
    // visualize {
    graphTracer.select(slow.val)
    graphTracer.visit(fast.val)
    Tracer.delay()
    graphTracer.deselect(slow.val)
    graphTracer.leave(fast.val)
    // }
    while (slow !== fast) {
        slow = slow.next
        fast = fast.next.next
        // visualize {
        graphTracer.select(slow.val)
        graphTracer.visit(fast.val)
        Tracer.delay()
        graphTracer.deselect(slow.val)
        graphTracer.leave(fast.val)
        // }
    }

    // 2. where does the cycle start?
    let cycleStartPosition = 0
    slow = head
    // visualize {
    graphTracer.select(slow.val)
    graphTracer.visit(fast.val)
    Tracer.delay()
    graphTracer.deselect(slow.val)
    graphTracer.leave(fast.val)
    // }
    while (slow !== fast) {
        slow = slow.next
        fast = fast.next
        cycleStartPosition += 1
        // visualize {
        graphTracer.select(slow.val)
        graphTracer.visit(fast.val)
        Tracer.delay()
        graphTracer.deselect(slow.val)
        graphTracer.leave(fast.val)
        // }
    }

    // 3. what is the length of the cycle?
    let cycleLength = 1
    fast = slow.next
    // visualize {
    graphTracer.select(slow.val)
    graphTracer.visit(fast.val)
    Tracer.delay()
    graphTracer.deselect(slow.val)
    graphTracer.leave(fast.val)
    // }
    while (slow !== fast) {
        fast = fast.next
        cycleLength += 1
        // visualize {
        graphTracer.select(slow.val)
        graphTracer.visit(fast.val)
        Tracer.delay()
        graphTracer.deselect(slow.val)
        graphTracer.leave(fast.val)
        // }
    }

    return {
      cycleLength,
      cycleStartPosition,
    }
}
// log {
const res = listHasCycle(list)
logTracer.print(`cycle start position: ${res.cycleStartPosition}`)
logTracer.print("\n")
logTracer.print(`cycle length: ${res.cycleLength}`)
// }

================
File: Simple Recursive/Euclidean Greatest Common Divisor/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

const a = [];
a.push(465);
a.push(255);

// define tracer variables {
const tracer = new Array1DTracer('Euclidean Algorithm');
tracer.set(a);
const logger = new LogTracer();
Layout.setRoot(new VerticalLayout([tracer, logger]));
Tracer.delay();
// }

// logger {
logger.println(`Finding the greatest common divisor of ${a[0]} and ${a[1]}`);

logger.println('Checking if first number is at most the second number');
// }

if (a[0] > a[1]) {
  const tmp = a[0];
  a[0] = a[1];
  a[1] = tmp;
  // logger {
  logger.println('The first number is bigger than the second number. Switching the numbers.');
  // }
  // visualize {
  tracer.set(a);
  Tracer.delay();
  // }
}

while (a[0] > 0) {
  // logger {
  logger.println(`${a[1]} % ${a[0]} = ${a[1] % a[0]}`);
  logger.println('Switching a[1] with a[1]%a[0]');
  // }
  a[1] %= a[0];
  // visualize {
  tracer.patch(1, a[1]);
  Tracer.delay();
  // }
  // logger {
  logger.println('Now switching the two values to keep a[0] < a[1]');
  // }
  const tmp = a[0];
  a[0] = a[1];
  a[1] = tmp;
  // visualize {
  tracer.patch(0, a[0]);
  tracer.patch(1, a[1]);
  Tracer.delay();
  tracer.depatch(0);
  tracer.depatch(1);
  // }
}

// logger {
logger.println(`The greatest common divisor is ${a[1]}`);
// }

================
File: Simple Recursive/Nth Factorial/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

// define tracer variables {
var tracer = new Array1DTracer('Sequence');
Layout.setRoot(new VerticalLayout([tracer]));
var index = 15;
var D = [1];
for (var i = 1; i < index; i++) {
  D.push(0);
}
tracer.set(D);
Tracer.delay();
// }

function fact(num) {
  if (num < 0) {
    return;
  }

  if (num === 0) {
    return 1;
  }

  var res = num * fact(num - 1);

  D[num - 1] = res;
  
  // visualize {
  tracer.select(num - 1);
  Tracer.delay();
  tracer.patch(num - 1, D[num - 1]);
  Tracer.delay();
  tracer.depatch(num - 1);
  tracer.deselect(num - 1);
  // }

  return res;
}
fact(index);

================
File: Simple Recursive/Suffix Array/code.js
================
// import visualization libraries {
const { Tracer, Array1DTracer, Array2DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');
// }

let word = 'virgo';
const suffixArray = (function skeleton(word) {
  const arr = [];

  for (let i = 1; i <= word.length + 1; i++) {
    arr.push([i, '-']);
  }

  return arr;
}(word));

// define tracer variables {
const saTracer = new Array2DTracer('Suffix Array');
const wordTracer = new Array1DTracer('Given Word');
const logger = new LogTracer('Progress');
Layout.setRoot(new VerticalLayout([saTracer, wordTracer, logger]));

saTracer.set(suffixArray);
wordTracer.set(word);
Tracer.delay();
// }

word += '$'; // special character
// logger {
logger.println('Appended \'$\' at the end of word as terminating (special) character. Beginning filling of suffixes');
// }

function selectSuffix(word, i) {
  let c = i;

  while (i < word.length - 1) {
    // visualize {
    wordTracer.select(i);
    // }
    i++;
  }
  // visualize {
  Tracer.delay();
  // }

  while (c < word.length - 1) {
    // visualize {
    wordTracer.deselect(c);
    // }
    c++;
  }
  // visualize {
  Tracer.delay();
  // }
}

(function createSA(sa, word) {
  for (let i = 0; i < word.length; i++) {
    sa[i][1] = word.slice(i);

    selectSuffix(word, i);
    // visualize {
    saTracer.patch(i, 1, sa[i][1]);
    Tracer.delay();
    saTracer.depatch(i, 1);
    Tracer.delay();
    // }
  }
}(suffixArray, word));

// logger {
logger.println('Re-organizing Suffix Array in sorted order of suffixes using efficient sorting algorithm (O(N.log(N)))');
// }
suffixArray.sort((a, b) => {
  // logger {
  logger.println(`The condition a [1] (${a[1]}) > b [1] (${b[1]}) is ${a[1] > b[1]}`);
  // }
  return a[1] > b[1];
});

// visualize {
for (let i = 0; i < word.length; i++) {
  saTracer.patch(i, 0, suffixArray[i][0]);
  saTracer.patch(i, 1, suffixArray[i][1]);
  Tracer.delay();

  saTracer.depatch(i, 0);
  saTracer.depatch(i, 1);
}
// }



================================================================
End of Codebase
================================================================
